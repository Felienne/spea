<h2>01 Chapter 1.1 - About Printing</h2><h3>01 Printing numbers</h3>While programming you will often want to 'print' something to the screen. In Python, you use the print() function for that. <br>It prints what ever is between the round brackets.<div><br></div><div>Like this:</div><div><pre><code>print(12)</code></pre><div><span><br>Will result in printing:</span><br></div></div><div><b>12</b><br>  <div><br></div><div>Try it in the next step.</div></div><br>This code prints the number <b>17</b>. Change it so that it prints <b>19</b>.</br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/01 Printing numbers/77110_02_code.step.py</p><hr><p><code>print(17)</code></p><hr><br>This code prints the number <b>1.4</b>. Change it so that it prints <b>3.5</b>.</br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/01 Printing numbers/77110_03_code.step.py</p><hr><p><code>print(1.4)</code></p><hr><br><p></p><p>While programming, you must be very precise. </p><p></p><pre><code>print(1.5)</code></pre><br> is not the same as <br><br><pre><code>print(1,5)</code></pre><p></p><p>Change the __ so the code prints <b>2 7</b>.</p><p></p></br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/01 Printing numbers/77110_05_code.step.py</p><hr><p><code>print(__)</code></p><hr><h3>02 Printing text</h3>In the previous lesson we printed numbers, like this:<br>print(5) --&gt; 5<br>print(1,5) --&gt; 1 5 <div>print(1.5) --&gt; 1.5  <div><br></div><div>We can also print words. That works (a bit) differently. <div><span>For also use </span><span>print and the round brackets (), but we add single quotes:</span></div></div></div><div><span>print('Hello') --&gt; Hello</span></div><br><p>Change the __ such that it prints the text<i> <b></b></i><b>Hello</b><b>﻿</b>.<b><i></i></b><br> </p></br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_02_code.step.py</p><hr><p><code>print('__')</code></p><hr><br>Change the __ such that it prints the text<i> <b></b></i><b>Hello</b><b></b>.</br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_03_code.step.py</p><hr><p><code>__('Hello')</code></p><hr><br>Change the __ such that it prints the text<i> <b></b></i><b>Hello</b><b></b>.</br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_04_code.step.py</p><hr><p><code>print(__Hello__)</code></p><hr><br>Now print something fun! Like <b>super cali fragilistic expialidocious</b> or<b> axolotl</b>.<b></b> <b></b><div><br></div><div>Warning: the code will fail if you print something fun, so after trying, use <b>print()</b> to make the assignment work.</div></br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_05_code.step.py</p><hr><p><code></code></p><hr>Printing in Python can be done with print and round brackets () and single quotes '', like we have seen before:<div><pre><code>print('axolotl')</code></pre><br>But, it can also be done with double quotes "":</div><div><pre><code>print("axolotl")<br></code></pre><b></b></div><div><b><br></b></div><div><b></b>These lines of Python mean exactly the same.</div><div><span><br></span></div><div><span>However, a double quote must be paired with another double one, and a single one with a single one!</span></div><div><b></b></div><div><b><br></b></div><div><b></b><br></div><br><p>Print <b>Bonjour</b>﻿ using double quotes.</p></br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_07_code.step.py</p><hr><p><code>print("__")</code></p><hr><br>Double quotes are useful when you want to print a text containing a single quote, like:<div><br></div><div><b>Don't leave me this way!</b></div><div><b><br></b></div><div><b></b>Print this text using double quotes<b></b></div></br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_08_code.step.py</p><hr><p><code>print("Dont leave me this way!")</code></p><hr><br><div>Similarly, single quotes can be used when you print a sentence with double quotes in it:</div><div><br></div><b>She said: "Go Away!"</b><div><b><br></b></div><div>﻿Use single quotes to print that sentence.<b><br></b></div></br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_09_code.step.py</p><hr><p><code>print('She said: Go Away!')</code></p><hr><br>Sometimes you will want to print a new line character, such that you can print multiple sentences:<div><br></div><div><b>Hello!</b></div><div><b>My name is what?</b></div><div><b><br></b></div><div>You do this with a special character: \n <b><br></b></div><div><br></div><div>Like this:</div><div><br></div><div><pre><code>print("Hello!\nMy name is what?")</code></pre><br></div><div>Note there is no space after the \n character. If you add it, a space would appear on the second line (try it!)</div><div><br></div><div>Now you print this:</div><div><br></div><div><b>Ahem, excuse me</b><br><b>Can I have the attention of the class</b><br><b>For one second?</b></div></br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_10_code.step.py</p><hr><p><code>print("__")</code></p><hr><br>You can print multiple lines using triple double (so using 3 times ") quotes """<div>Even though these are technically six quotes, in Python they are usually called triple quotes.</div><div><br><div><div>For example, you would print these lines:</div><div><br></div><div><b>Hello!</b></div><div><b>Is it me</b></div><div><b>You are looking for?</b><br></div><div><br>Like this:</div><div><br></div><div><pre><code>print("""Hello!
Is it me
You are looking for?""")</code></pre><br></div><div>Now can you print this?<br></div><div><br></div><div><b>I can see it in your eyes</b><br><b>I can see it in your smile</b></div></div></div></br><p>Code below is found in Python files/01 Chapter 1.1 - About Printing/02 Printing text/77111_11_code.step.py</p><hr><p><code>print("""__""")</code></p><hr><h2>02 Chapter 1.2 - About Assignments</h2><h3>01 Storing numbers</h3>In the previous lesson we have printed numbers and texts. In this lesson we are going to store numbers and texts!<div><br></div><div>To store things we use <i>variables.</i>﻿ A variable is a name we give to a value, like temperature, pressure, age or angle. To store a variable we use a name, an equals sign and the value, like this:</div><div><br></div><div><pre><code>temperature = 21</code></pre><br></div><div><br></div><div><br></div><div><br></div><br><p>Store 27 in the variable temperature. Line 2 prints the value of temperature so if you fill it correctly it will print <b>137</b>.</p><p><br></p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/01 Storing numbers/78604_02_code.step.py</p><hr><p><code>temperature = __
print(temperature)</code></p><hr>We just stored a whole number in a variable. In Python and other programming languages this is called an <i>integer</i>.<div><br></div><div>We can also store non-integers. In Python we call those <i>floats</i>. The syntax to store them is the same:</div><div><br></div><div><pre><code>pi = 3.14159</code></pre><br></div><br><p>Store 2.718281828 in the variable e. Line 2 prints the value of e so if you fill it correctly it will print <b>2.718281828</b>.</p><p><br></p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/01 Storing numbers/78604_04_code.step.py</p><hr><p><code>e = __
print(e)</code></p><hr>Once a number is stored, we can of course do more with it than just printing!<div><div>For example, we can use it in calculations:</div></div><div><br></div><div></div><pre><code><div>temperature = 10</div><div>increase = 2</div><div>temperature = temperature + increase</div></code></pre><div></div><div><br></div><div>After this snippet of code temperature will be equal to 12</div><div><br></div><br>Change the increase of temperature such that the code ends with temperature set to 17.</br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/01 Storing numbers/78604_06_code.step.py</p><hr><p><code>temperature = 10
increase = 2
temperature = temperature + increase
print(temperature)</code></p><hr><div><div>In the previous exercise we updated the value of an existing variable, like this:</div><div><br></div><div></div><pre><code><div>temperature = 10<br></div><div>increase = 7</div><div>temperature = temperature + increase</div></code></pre><div></div><br></div><div>This code has shown that﻿ v<b></b>ariables in programming are different from variables in mathematics, in that they can change their value!</div><div>A statement like x = x + 1 would not make sense in math, but it does in Python!</div><div><br></div>Sometimes, you want to assign two variables in one line of code. Not all programming languages can do this, but Python can. It works like this:<div><br></div><div><pre><code>power, angle = 100, 12</code></pre><br></div><div><span>This line of Python is exactly equal to </span><br></div><div><br></div><div></div><pre><code><div>power = 100<br></div><div>angle = 12</div></code></pre><div><br></div><div>However it is more compact, and that is why Python programmers like it.</div><br>Store 5 in the variable power, and 27 in the variable angle.<br><br><div>Line 2 prints the value of <i>both values, </i>so if you fill them correctly it will print <b>5</b> <b>27</b>.</div></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/01 Storing numbers/78604_09_code.step.py</p><hr><p><code>power, angle = __, __
print(power, angle)</code></p><hr><br><p>A nice aspect of multi assign is that you can use it to swap values.<br></p><p>Use multi assign to assign to set small_number to 12 and large_number to 100. </p><p><br></p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/01 Storing numbers/78604_10_code.step.py</p><hr><p><code>small_number = 100
large_number = 12
small_number, large_number = __, __

print(small_number, large_number)</code></p><hr><h3>02 Types of numbers</h3><br><p>Make temperature store 27. The program prints the value of temperature so if you store the correct value if will print <b>27</b>.<b></b></p><p><br></p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/02 Types of numbers/78605_02_code.step.py</p><hr><p><code>temperature = __
print(temperature)</code></p><hr><h3>03 Storing strings</h3><br><p>Now that we have stored integer and float numbers, we can also store strings, with the same syntax:</p><div><pre><code>name = 'Harry'</code></pre></div><br><p></p><div>Try it in the next step!</div></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/03 Storing strings/78606_01_code.step.py</p><hr><p><code># put your python code here</code></p><hr><br><p>Store <b>Sally</b> in the variable name, using single quotes 'Sally'</p><p>Line 7 prints the value of name so if you fill it correctly it will print <b>Sally</b>.</p><p><br></p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/03 Storing strings/78606_02_code.step.py</p><hr><p><code>name = __
print(name)</code></p><hr><p>Remember we could print strings with single quotes '<b>﻿</b> but also with double quotes ". These two lines of Python are equal to each other:</p><p></p><pre><code>print('Hank')</code></pre><p></p><p></p><pre><code>print("Hank")</code></pre><p></p><p>Similarly, you can use both ' '(single quotes) and " "(double quotes) to store strings. As such, these two lines of Python are equal too:</p><p></p><pre><code>name = 'Harry'</code></pre><p></p><p></p><pre><code>name = "Harry"</code></pre><br><p></p><p><br></p><br><p>Store <b>Sally</b> in the variable name, using double quotes ""</p><p>Line 7 prints the value of name so if you fill it correctly it will print <b>Sally</b>.</p><p><br></p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/03 Storing strings/78606_04_code.step.py</p><hr><p><code>name = __ 
print(name)</code></p><hr>Remember we could also print strings with triple double quotes """, like this:<div><br></div><div>print("""Hello"""")</div><div><br></div><br><p>We can also store multiline strings in a variable with triple quotes:</p><p></p><pre><code>lola = """Lola<br>LoLoLo<br>Lo<br>La<br>""")</code></pre> <p><br>Can you store and print these lines:</p><p><b>Ow </b><br><b>Denis </b><br><b>doo be do</b></p><p>Like before line 2 prints the stored string.</p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/03 Storing strings/78606_07_code.step.py</p><hr><p><code>name = __ 
print(name)</code></p><hr><h3>04 About storing lists</h3><p>Like we store numbers and text, we can also store <i>lists</i>. We will work with lists a lot in Python, and there will be more extensive chapters on working with lists. In this section we focus on storing lists.</p><p>Storing in principle works like storing numbers and strings, we use a name followed by an equal sign:</p><p></p><pre><code>three_primes = </code></pre><p></p><p>After that, something special happens, we need to use an square bracket to enclose the list in:</p><p></p><pre><code>three_primes = [2, 3, 5]</code></pre><p></p><p>The items are separated with comma's. A space is not needed, but advised!</p><p><br></p><br><p>Change the value of five_primes such that it contains the values 2, 3, 5, 7, 11.</p><p>Note that again, line 2 prints the list. There is no special syntax for printing lists.</p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/04 About storing lists/78609_02_code.step.py</p><hr><p><code>five_primes = [__] 
print(five_primes)</code></p><hr><p>In the previous step we have stored a list of numbers, but we can have lists of anything we want!</p><p>For example a list of strings, like a list of students in a class. Again we start with a name and an equal signL</p><p></p><pre><code>students = </code></pre><p></p><p>Then again we use square bracket to enclose the list in:</p><p></p><pre><code>students = [                               ]</code></pre><p></p><p>But because we are talking about text strings now, we need to enclose each item in quotes (single or double) too:</p><p></p><pre><code>students = ['Mary', 'Lenny', 'Perry']</code></pre><p></p><p><span>Again, items are separated with comma's and (optional) spaces.</span><br></p><p></p><br><p>Change the value of songs such that it contains the values 'One', 'It takes two', 'Three blind mice'.</p><p>Note that again, line 2 prints the list. There is no special syntax for printing lists.</p></br><p>Code below is found in Python files/02 Chapter 1.2 - About Assignments/04 About storing lists/78609_04_code.step.py</p><hr><p><code>songs = [__] 
print(songs)</code></p><hr><h2>03 Chapter 1.3 - About Error messages</h2><h3>01 Python errors and where to find them</h3>In the previous lessons we have used print to print numbers, like this:<div><br><div><pre><code>print(17)</code></pre><br></div><div>Python requires both round closing brackets (not so surprising of course) and when you remove one, you will get an error. <br>Try it in the next step.</div></div><br><p>Execute the code without the final round bracket and see what happens!</p><p><b>Do not fix the code straight away.</b></p></br><p>Code below is found in Python files/03 Chapter 1.3 - About Error messages/01 Python errors and where to find them/80484_02_code.step.py</p><hr><p><code>print(17</code></p><hr><p>In the previous step you saw this error:</p><p><img alt="" src="https://ucarecdn.com/ff8c7076-b77c-4fab-b288-dc304c6947df/" title="Image: https://ucarecdn.com/ff8c7076-b77c-4fab-b288-dc304c6947df/"><br>Corresponding to this code:</p><p></p><pre><code>print(17</code></pre><br><p></p><p>You could say that this is not helpful at all and that it leaves you confused.</p><p>What is SyntaxError? What is EOF, what is parsing? Do not despair, we will explain all of this now.</p><p><br></p><p class="wysiwyg-text-align-left">Let's look at that error again:</p><p class="wysiwyg-text-align-left"><span class="image-wrapper"><img alt="" src="https://ucarecdn.com/1db4710b-69ba-498c-9a2d-4997db53d21f/" title="Image: https://ucarecdn.com/1db4710b-69ba-498c-9a2d-4997db53d21f/"></span></p><p></p><p>Corresponding to this code:</p><p></p><pre><code>print(17</code></pre><br><p></p><p>We can ignore the first line for now, and also the first part of the second line "File jailed_code", is not relevant now. </p><p>The rest of the error message has some valuable information though!</p><h2>,line 2</h2><p>Here, Python tells us where the error is located, in line 2. Sadly, in this case this is not entirely correct, the error is in line 1. In some cases we will see later it is correct. It is often correct but not always.<br></p><h2>SyntaxError:</h2><div><br></div><div>Here Python explain the type of the error <i>SyntaxError</i>. You can think of them as spelling mistakes. You made a mistake in spelling Python correct, and therefor Python is now confused about what you mean.<i></i></div><div><br></div><div>We will see a variety of these errors and in your programming career you will see a lot more, I am sure :-)</div><div><br></div><h2>while parsing (can also be while scanning)</h2><div>In this error you see 'while parsing' and in others you will see 'while scanning' Those are different steps in the process of running Python on your computer, but for now, just think of them as 'reading'. So the error we just got:</div><div><br></div><div>", line 2<br>SyntaxError: unexpected EOF while parsing"<br></div><div><br></div><div>Actually means:<br><br>In line 2 something weird happened.<br>You made a spelling mistake: unexpected EOF while reading.</div><div><br></div><h2>EOF</h2><p>So the only thing we still need to decipher now is EOF. It means 'end of file'. So the error means that Python reaches the end of the file while reading it, and did not expext to see the end of the file yet. This is because it was still looking for a closing round brackets.<br></p><p>Let's make another mistake and learn about a new error!</p>In the previous lessons we have used variables to store text too, like this:<div><br><div><pre><code>name = "Harry"
print(name)</code></pre><br></div><div>Python requires both double quotes too, and if we omit them, we will get an error.<br></div></div><div>Try it in the next step.</div><br><p>Execute the code without the final double quote and see what happens!<br></p><p><b>Do not fix the code straight away.</b></p><p>Once you have read the error message, fix the code so that it print <b>Jetson</b>.</p></br><p>Code below is found in Python files/03 Chapter 1.3 - About Error messages/01 Python errors and where to find them/80484_06_code.step.py</p><hr><p><code>name = "Jetson
print(name)</code></p><hr><p>In the previous step we got another error message this time:</p><p><img alt="" src="https://ucarecdn.com/074ce6dd-7b48-466c-aff6-91479910e187/" title="Image: https://ucarecdn.com/074ce6dd-7b48-466c-aff6-91479910e187/"></p><p>Corresponding to this code:</p><p></p><pre><code>name = "Jetson &lt;-- the error is here<br>print(name)</code></pre> <br>This error is another SyntaxError, or a spelling mistake, and again we get an error while 'scanning' which you can think or like reading.<br><p></p><p>This time Python encounters an EOL while reading, or an 'end of line'. So Python reaches the end of the line, but does not expect it (since it is expecting a double quote). </p><p>This time however, we get extra bonus help, in the form of the ^. It points to the place where Python thinks the error is. Sadly this is not always correct, but it is now. So when you get an error, read it carefully and examine where the ^ is placed, if it is there.</p><p><br></p><p>In previous lessons we have printed text, like this:</p><p></p><pre><code>name = "Gary"<br>print(name)</code></pre> <br>But, sometimes you misspell a word, like this:<p></p><p></p><pre><code>name = "Gary"<br>prnt(name)</code></pre> <br>This too will lead to an error, but a new one!<br>Try it in the next step.<br><p>Execute the code with the wrong spelling of print and see what happens!<br></p><p><b>Do not fix the code straight away.</b></p></br><p>Code below is found in Python files/03 Chapter 1.3 - About Error messages/01 Python errors and where to find them/80484_09_code.step.py</p><hr><p><code>name = "Betty"
prnt(name)</code></p><hr><div>In the previous step, you have seen this error:</div><div><br></div><img alt="" src="https://ucarecdn.com/476b61e1-d4ed-4482-b86c-57a841d302d4/" title="Image: https://ucarecdn.com/476b61e1-d4ed-4482-b86c-57a841d302d4/"><p><br></p><p>More confusing information this time. We can ignore the first line for now, and also the second line starting with Traceback.</p><p>, line 2, again indicates where the error is, which is correct in this case:</p><p></p><pre><code>name = "Betty"<br>prnt(name)  &lt;-- the error is here</code></pre><p></p><h2>NameError<br></h2><p>We then get a NameError, which is a bit different from a SyntaxError. For a SyntaxError, Python can decide straight away if it is wrong. For a name error, however, Python needs to do a bit more work. It needs to decide if there is a function called prnt and check in all existing functions.</p><p>There is no function called prnt, but there could be one! In fact in later lessons we will teach you how to create your own and then you can pick any name.<br><br>This is why we get a NameError, Python has tried all existing names but there is nothing called prnt. This is summarized in the explanation that 'name 'prnt' is not defined.<br><br></p><br>Write crazy code and see what error message you get! Can you get crazy ones?<br>Share them in the next step.</br><p>Code below is found in Python files/03 Chapter 1.3 - About Error messages/01 Python errors and where to find them/80484_11_code.step.py</p><hr><p><code></code></p><hr><h2>04 Chapter 1.4 - About Asserts</h2><h3>01 Asserting the truth</h3><p class="wysiwyg-text-align-left"></p><p>Now that you have set your first steps in Pythonland, we can learn a new programming concept. The assert.</p><p>An assert is used to check whether something is true. It can be very helpful when writing programs, since we can use it to verify things of which we assume they are true. Because you will see that we sometimes assume things that are not true at all!</p><p>Let's think of something that is True. For example 1+1 is equal to 2. <br>There is a special command in Python to check if something is true or not. </p><p></p><pre><code>assertEqual(1+1, 2)</code></pre><p><br>You can think of this as saying: <i>"Python, can you please check whether 1+1 is equal to 2?"</i><br><br>Run the code in the next step.</p><p>What do you think? Is 1+1 equal to 2?</p><p></p><br><p>Run the code and verify that 0 is indeed not 1!</p></br><p>Code below is found in Python files/04 Chapter 1.4 - About Asserts/01 Asserting the truth/51270_02_code.step.py</p><hr><p><code>assertEqual(1+1, 2)</code></p><hr>Now let's try something more crazy and ask Python to verify that 1+1 = 5, which is course is wrong.<br><br>What would happen if we feed the assertEqual two things that are not equal?<br>Run the code and see what happens when we assert a weird statement like 1+1 is 5...</br><p>Code below is found in Python files/04 Chapter 1.4 - About Asserts/01 Asserting the truth/51270_04_code.step.py</p><hr><p><code>assertEqual(1+1, 5)</code></p><hr><div>In the previous step we had:</div><div><br></div><div><pre><code>assertEqual(1+1, 5)</code></pre><br></div><div>This resulted in:</div><br><img alt="" src="https://ucarecdn.com/c3efc3ac-78ad-4ec3-88be-61528e706a5f/" title="Image: https://ucarecdn.com/c3efc3ac-78ad-4ec3-88be-61528e706a5f/"><div><br></div><div>So when you feed assertEqual two things that are not equal to each other, you get a new type of error, an AssertionError.<br></div><div><br></div><div>It also tells you what two things are not equal: 2 is not 5.<br><br></div><br><p>In previous lessons we have seen __, the value "Blank".<br><br>In many steps that are still to follow, you will use __ and assertEqual together. <br><br>Try it in this step first (without changing anything)!</p><p>After that you may change the value so that the assertEqual becomes true.</p></br><p>Code below is found in Python files/04 Chapter 1.4 - About Asserts/01 Asserting the truth/51270_06_code.step.py</p><hr><p><code>assertEqual(1 + 3, __)</code></p><hr><div>The nice thing about assertEqual is that it shows us the values of the two things that were passed. <br>When you passed the values <b>4</b> and <b>__</b> you saw this error message:</div><div><br></div><div><img alt="" src="https://ucarecdn.com/dbd153cb-721a-454c-a6c8-adca042a12e8/" title="Image: https://ucarecdn.com/dbd153cb-721a-454c-a6c8-adca042a12e8/"><br></div><div>Here Python returns an AssertionError, but also shows the two values that are not the same: <b>4 is not Blank</b> </div><div>Blank denotes the two underscores __.<br></div>In a lot of subsequent puzzles, you will have to make sure an assertEqual 'passes'. That means we feed it two equal things and no error occurs when we run is.<br><div><br></div><div>Like we have done in previous puzzles, you will have to change the __  into the right value, but often, <span>the assertEquals will be combined with other statements, like assignments. That means the blank can be in different places that in the assert itself:</span></div><div><br><pre><code>expected_value = __  &lt;-- the blank is here<br>actual_value = 1 + 1<br>assertEqual(expected_value, actual_value) &lt;-- but this is the assertEquals that has to pass</code></pre> <br></div><div>Try it in the next step!</div><br><p>Make the assertEqual pass by changing the blank.</p></br><p>Code below is found in Python files/04 Chapter 1.4 - About Asserts/01 Asserting the truth/51270_09_code.step.py</p><hr><p><code>expected_value = __
actual_value = 1 + 1
assertEqual(expected_value, actual_value)</code></p><hr>Sometimes one puzzle will have multiple assertEquals, like this:<div><br></div><div></div><pre><code><div>assertEqual(1+4, __)<br></div><div>assertEqual(2+7, __)</div></code></pre><div><br></div><div>In this case, you will have to make sure both of the assertEqual's must be correct for the whole program to work. </div><div>If you solve just one, you will still get an error. </div><div><br></div><div>Try this in the next step!</div><br><p>Explore how two assertEqual's work in one program.</p></br><p>Code below is found in Python files/04 Chapter 1.4 - About Asserts/01 Asserting the truth/51270_11_code.step.py</p><hr><p><code>assertEqual(1+4, __)
assertEqual(2+7, __)</code></p><hr><h2>05 Chapter 1.5 - About Lists</h2><h3>01 List basics</h3><p>Lists are an important part of programming. Often you want to store more than just one number or text. In the About assignment lesson we have already seen the basic syntax of a list. You choose a variable name, an equal sign and then rectangular brackets to separate the items.</p><p></p><pre><code>temperatures_this_week = [10, 11, 17, 18, 21, 22]</code></pre><p></p><p><span>If the items are strings, they need to be enclosed in quotes (single or double):</span><br></p><p></p><pre><code>beatles = ['John', 'Ringo', 'Paul', 'George']</code></pre><br><p></p><br>Create a list containing the numbers 5 and 12.</br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/01 List basics/78629_02_code.step.py</p><hr><p><code>two_numbers = [__] 
assertEqual(two_numbers, [5, 12])</code></p><hr>It often matters how many items are in a list, and for this Python has a special function, called len(). It is short for length. <div><br></div><div>Like print you use it with two round brackets. We store the length in a new variable called length:<div><br></div><div></div><pre><code><div>two_numbers = [5, 12]<br></div><div>length = len(two_numbers)</div></code></pre><div></div><div><br></div><div>After this code, the variable length contains the number 2. <br>Try it in the next step!</div></div><br><p>Fill the list such that it contains 2 numbers.</p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/01 List basics/78629_04_code.step.py</p><hr><p><code>two_numbers = [__]
length = len(two_numbers)
assertEqual(length, 2)</code></p><hr>You can also create an empty list. That sounds weird but it can be useful, for example if you will be filling the list later. <div><br></div><div>An empty list is created with just two rectangular brackets, like this:</div><div><br></div><div><pre><code>nothing = []</code></pre></div><div><br></div><br>What is the length of an empty list?</br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/01 List basics/78629_06_code.step.py</p><hr><p><code>nothing = []
length = len(nothing)
assertEqual(length, __)</code></p><hr><h3>02 Adding elements</h3>So far we have created lists at once, by assigning a whole list to a variable:<div><br></div><div><pre><code>one_direction = ['Niall', 'Liam', 'Harry', 'Louis']</code></pre> </div><div><br>But later in programming, often we will be constructing lists in a different way.<br>For example, reading temperatures from a sensor, or reading words from a text file. </div><div><br></div><div>In that scenario, you start with an empty list, and add elements step by step.</div><div><br></div><div>We will discover how to in the next steps.<br></div><br><p>In this code snippet you learn about one way of adding elements to a list, the append statement.</p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/02 Adding elements/80553_02_code.step.py</p><hr><p><code>lucky_numbers = []
lucky_numbers.append(4)
assertEqual(lucky_numbers, __)
lucky_numbers.append(8)
assertEqual(lucky_numbers, __)</code></p><hr>The append statement you have just seen works a bit differently from what we have seen before. <div><br></div><div>It has a format with a dot that we have not seen before.<div><br><div></div><pre><code><div>lucky_numbers.append(4)<br></div></code></pre><div><br></div><div>What this means is we take a list (called lucky_numbers) and to that we append an element (the element 4 in this case)</div><div><br></div><div>Append here is called a <i>method</i>, <span>and lists support a number of different methods. If you are interested to explore what can be done with lists, the <a href="https://docs.python.org/2/tutorial/datastructures.html">Python docs</a> are a good place to start. However we will encounter the most important methods in later lessons.</span></div></div></div><div><span><br></span></div>You might wonder why we want to store things in lists at all! Why not just use a bunch of variables, like this:<div><br></div><div></div><pre><code><div>number_1 = 4</div><div>number_2 = 8</div><div>...</div></code></pre><div></div><div><br></div><div>Well in addition to append, lists can be used to do some useful things!</div><div><br></div><div>For example, we can use the count method to count the number of items of with certain value. Like this:</div><div><br><pre><code>temperatures_this_week = [21, 20, 18, 19, 20, 20]<br>twenty_days = temperatures_this_week.count(20)</code></pre> </div><div><br>What do you think this will result in? Try it in the next step.</div><div><br></div><br>Explore the meaning of the count method by filling the blank.</br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/02 Adding elements/80553_05_code.step.py</p><hr><p><code>temperatures_this_week = [21, 20, 21, 19, 20, 20]
twenty_days = temperatures_this_week.count(__)  
assertEqual(twenty_days, 2)</code></p><hr><br>Explore the meaning of the count method by filling the blank.</br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/02 Adding elements/80553_06_code.step.py</p><hr><p><code>temperatures_this_week = [21, 20, 21, 19, 20, 20]
twenty_days = temperatures_this_week.count(20)  
assertEqual(twenty_days, __)</code></p><hr><h3>03 Accessing elements</h3>Once we have created a list, like this:<div><br></div><div><pre><code>temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]</code></pre></div><div><br></div><div>Sometimes we want to get a specific element from a list, for example the first element, 21 in this case.</div><div><br></div><div>Explore this in the next step, it might be a bit weird!</div><div><br></div><br>Try to get the first element of the list temperatures_this_week into the variable temperature_monday.<div><br></div><div>Note: The blank is at line 3, and it needs to be filled with a number.</div></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/03 Accessing elements/80555_02_code.step.py</p><hr><p><code>temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]
temperature_monday = temperatures_this_week[__]
assertEqual(temperature_monday,21)</code></p><hr><p>Well that was weird, wasn't it? If you want to get the first element of a list, you need to get element zero (0):</p><p></p><pre><code><p>temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]<br>temperature_monday = temperatures_this_week[__]<br>assert(temperature_monday == 21)<br></p>temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]<br>temperature_monday = temperatures_this_week[0] &lt;-- this gets us 21<br></code></pre><div><br></div>This is a very old convention in programming, if you want to read more about the rationale, maybe check out <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" title="Link: https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html">this post by Dutch computer scientist Dijkstra</a>. Not all programming languages follow it though, if you have used MatLab before, you know that is starts at 1, and so does an old language COBOL.<br>Let's practice the list indexes a bit more! Fill the blanks to make the asserts pass.</br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/03 Accessing elements/80555_04_code.step.py</p><hr><p><code>beatles = ['John', 'Paul', 'George', 'Ringo']
assertEqual(beatles[0], __)
assertEqual(beatles[3], __)</code></p><hr>Maybe you cannot imagine it yet, but sometimes you want to start at the end of a list, that is also possible by using negative numbers in between the rectangular brackets:<div><br></div><div><pre><code>beatles = ['John', 'Paul', 'George', 'Ringo']<br>assert(beatles[-1] == __)<div><div></div></div></code></pre><div><div><br></div><div>Try it in the next step!</div></div></div><br><p>Negative numbers get elements from the end of a list.<br>Fill the blanks to make the assertEqual's pass.<br></p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/03 Accessing elements/80555_06_code.step.py</p><hr><p><code>beatles = ['John', 'Paul', 'George', 'Ringo']
assertEqual(beatles[-1], __)
assertEqual(beatles[-2], __)
assertEqual(beatles[-3], __)</code></p><hr><p>Okay, maybe that was tricky indeed! When reading a list from the end, we do start at (negative) 1 and not zero. <br>It makes some sense since -0 is equal to 0, but still. </p><p>This is really tricky, so do not worry! The fact that you start at zero can take some getting used to, it still confused me sometimes after decades of programming!</p><h3>04 Creating lists from ranges</h3><p>We can now create lists in two ways, directly assigning a number of elements:</p><p></p><pre><code>one_direction = ['Niall', 'Liam', 'Harry', 'Louis']</code></pre><p></p><p>Or, starting with an empty list and then appending elements:</p><p></p><pre><code>lucky_numbers = []<br>lucky_numbers.append(4)<br>lucky_numbers.append(8)</code></pre> <br>There is one more way that you will use a lot and that is by using the range function. <br>We will explore how in the next steps.<br><p></p><div><br></div><p>Range is a function that creates a range of numbers, like this:</p><p></p><pre><code>zero_to_five = range(0,5)<br></code></pre> <p></p><p>This range represents the numbers 0 to 4 (not including 5!)<br><br>Note that a range is not a list!<br>Explore it in the next step.</p><p><br></p><br><p>Remember how to create a list directly? <span>Create a list in line 1 with them numbers 0 to 5.</span></p><p>Then in line 3 create a range (not a list!) from 0 to 5.</p><p>The assertEqual checks if they are the same. Are they?</p><p><br></p><p><br></p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/04 Creating lists from ranges/80564_03_code.step.py</p><hr><p><code>zero_to_five_list = [__, __, __, __, __]
zero_to_five_range = range(0,__)
assertEqual(zero_to_five_range, zero_to_five_list)</code></p><hr>As you have seen ranges are different from lists because an assertEqual shows they are not equal. <br><br>Trying to print variables to see what they contain is a good strategy to use, also when you will be programming bigger programs later.<div><br></div><div>But, we can also verify this in code. As you move on in these lesson and will work more with different types, it is useful to know how to check this. We will explore it in the next step.</div>As you have seen ranges are not lists. But because they are similar we can convert a range into a list using the list() method:<div><br></div><div></div><pre><code><div>zero_to_five_range = range(0, 5)      #&lt;-- this is a range<br></div><div>zero_to_five_list = list(zero_to_five_range) #&lt;-- using list(...) we transform the range into a list<br>print(zero_to_five_list)              #&lt;-- the list is printed</div></code></pre><div><br>This code nicely prints the numbers 0 to 4. Try it in the next step.<br><br><br></div><br>Print the numbers 0 to 4 using a range converted to a list in line 3.<br>Also assert that the list is equal to 0 to 4 in line 4. </br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/04 Creating lists from ranges/80564_06_code.step.py</p><hr><p><code>zero_to_five_range = range(0, 5)     
zero_to_five_list = list(zero_to_five_range)
print(zero_to_five_list)
assertEqual(zero_to_five_list, __)</code></p><hr>Most often when you will encounter a range that is converted to a list in this way:<div><br></div><pre><code>zero_to_five_list = list(range(0,5))</code></pre><div><br>This creates a range first, and then immediately converts in into a list.<br>Use this to create a list from 11 to 17 in the next step!</div><div><br></div><br>Create a list from 11 to 17 using a range and a list in one line on line 1.<div>Assert that you have created the right list on line 2.</div></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/04 Creating lists from ranges/80564_08_code.step.py</p><hr><p><code>eleven_to_seventeen_list = __(__(11,__))
assert(eleven_to_seventeen_list == [11, 12, 13, 14, 15, 16])</code></p><hr><p>If a list starts at zero, we do not need the first argument of the range method, it may be omitted.</p><p>That means that this line of code:</p><pre><code>zero_to_five_list = list(range(0,5))</code></pre><div><br><div>is equal to this line:</div><div><br></div><div><pre><code>zero_to_five_list_shorter = list(range(5))</code></pre><br></div></div><div>Try it in the next step.</div><br><p>Create a list form a range with one argument and assert this is the same as a list from 0 to 5.</p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/04 Creating lists from ranges/80564_10_code.step.py</p><hr><p><code>zero_to_five_list = list(range(0,5))
zero_to_five_list_shorter = list(range(__))

assert(zero_to_five_list == zero_to_five_list_shorter)</code></p><hr>You can add text and also images, math formulas, code examples and much more in this theory step.<br><p>What would these ranges create? </p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/04 Creating lists from ranges/80564_12_code.step.py</p><hr><p><code># put your python code here</code></p><hr><h3>05 Slicing</h3>In the previous lesson we retrieved one element at a time from lists, like this:<div><br></div><div><pre><code>temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]<br>temperature_monday = temperatures_this_week[0] &lt;-- this gets us 21</code></pre> <br></div><div>But sometimes we want to get a few elements out of a list, like the data on just the workdays from a week:</div><div><br></div><div><pre><code>begin = 0
end = 5
temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]<br>temperatures_weekdays = temperatures_this_week[begin:end] &lt;-- this gets us the list from begin (0) to end (5)</code></pre> </div><div><br>For this we use the : symbol, in between begin and end. We call those <i>indexes</i>.</div><div><br>Explore it in the next step.<br></div><br>Try to figure our the right answers to these <i>slices</i>.</br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/05 Slicing/80563_02_code.step.py</p><hr><p><code>colors = ['Black', 'White', 'Grey', 'Green', 'Pink']
grayscale = colors[0:3]
assertEqual(grayscale, __)

colors_with_g = colors[2:__]
assertEqual(colors_with_g, ['Grey', 'Green'])

nothing = colors[4:0]
assertEqual(nothing, __)</code></p><hr><br>Try to figure our the right answers to these <i>slices</i>.</br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/05 Slicing/80563_03_code.step.py</p><hr><p><code>dutch = ['nul', 'een', 'twee', 'drie', 'vier', 'vijf']
greater_than_three = dutch[4:6]
assertEqual(greater_than_three, __)

also_greater_than_three = dutch[4:100]
assertEqual(also_greater_than_three, __)

less_than_four = dutch[0:4]
assertEqual(less_than_four, __)

hoedje_van_papier = dutch[__:__]
assertEqual(hoedje_van_papier, ['een', 'twee', 'drie', 'vier'])</code></p><hr>Hier wat uitleg over de slices nog.Both parts (before and after the :) are optional and thus might be ommitted.<br>Explore what happens when you remove the index before or after the colon (:)</br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/05 Slicing/80563_06_code.step.py</p><hr><p><code>temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]
temperatures_weekend = temperatures_this_week[5:]
assertEqual(temperatures_weekend, __)

temperatures_weekdays = temperatures_this_week[:5]
assert(temperatures_weekdays == __)</code></p><hr>In the previous step you have seen that removing either the beginning or the end index leads to Python using the whole list. <div>This code:<br><br></div><div><pre><code>temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]
element 5 is here ----------------------------^-------

temperatures_weekend = temperatures_this_week[5:]</code></pre> </div><div><br>results in the data for just the weekend days (the final two days) because it starts at element 5 (20 in this case as indicated by the ^) and then takes all values to the end of the list.</div><div><br></div><div>Similarly this:</div><div><br></div><div><span></span></div><pre><code>temperatures_this_week = [21, 20, 18, 19, 20, 20, 10]
<div><span>element 5 is here ----------------------------^-------</span></div><div><span>temperatures_weekdays = temperatures_this_week[:5]</span><br></div></code></pre><div><br></div><div>results in the first 5 elements, from the beginning up to (not including) the fifth element.</div><div><br></div><div><br></div><br><p>Try to figure our the right answers to these <i>slices</i>.<br></p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/05 Slicing/80563_08_code.step.py</p><hr><p><code>measurements = [-6, -2, 0, 2, 6]
negative_values = measurements[:2]
assertEqual(negative_values, __)

postive_values = measurements[__:]
assertEqual(postive_values, [2, 6])

zero_and_above = measurements[__]
assertEqual(zero_and_above, [0, 2, 6])

last_element = measurements[4:]
assertEqual(last_element, __)

first_element = measurements[:__]
assertEqual(first_element, [-6])</code></p><hr><h3>06 in for lists</h3>If you want to know whether something is in a list, we can use the 'in' keyword. Like this:<div> <pre><code>primes = [2, 3, 5, 7, 11]
3 in primes &lt;-- this is True
12 in primes &lt;-- this is False</code></pre> <div><br></div>Try it in the next step.<br><br></div><div><br></div><br><p>'in' determines whether an element contains a list. </p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/06 in for lists/78633_02_code.step.py</p><hr><p><code>beatles = ['John', 'Ringo', 'George', 'Paul']
one_direction = ['Harry', 'Niall', 'Louis', 'Liam', 'Zayn']
assertEqual('John' in __, True)
assertEqual(__ not in one_direction, False)</code></p><hr><h3>07 Inserting elements into lists</h3><br><p>Try to figure out these insertions into lists.</p></br><p>Code below is found in Python files/05 Chapter 1.5 - About Lists/07 Inserting elements into lists/78639_01_code.step.py</p><hr><p><code>gandalf_says = ['you', 'will', 'pass']

gandalf_says[1] = 'shall'
assertEqual(__, gandalf_says)

gandalf_says.insert(2, 'not')
assertEqual(__, gandalf_says)

gandalf_says.insert(0, 'Arthur')
assertEqual(__, gandalf_says)</code></p><hr><h2>06 Chapter 1.7 - About Dictionaries</h2><h3>01 Dictionary basics</h3><p>In previous lessons we have seen lists as a means to store more items in one variable.</p><p>Python supports many more (we will not learn about all of them in this module!) <span class="wysiwyg-color-red">TODO hier evt een link naar module 2 als die er is als teaser.</span></p><p>But there is one we will learn: a dictionary.</p><p>A dictionary is like a list, but, it stores <i>pairs</i> of things. Imagine it looks like this internally. </p><p>1 --&gt; uno<br>2 --&gt; dos<br>3 --&gt; tres</p><p>Every value on the left (called a key) corresponds to a value on the right (called a value). </p><p>You create a dictionary like this:</p><p></p><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}</code></pre><p><span><br>If the items are strings, they need to be enclosed in quotes (single or double), like 'uno', 'dos' and 'tres' are in the example above. This is similar to making a list of strings: ['uno', 'dos' and 'tres']</span><br></p><p></p><p>Both the left and the right side, the key and the value, can be of any type, so this is a proper dictionary too:</p><p></p><pre><code>babel_fish_reverse = {'uno': 1,  'dos': 2, 'tres' :3}</code></pre><br><p></p><br><p>What is the length of a dictionary? Can you figure it out this this assignment?</p></br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/01 Dictionary basics/84041_02_code.step.py</p><hr><p><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}
assertEqual(__, len(babel_fish))</code></p><hr>As you have seen in the previous step, this dictionary:<br><br><div><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}</code></pre></div><div><br></div><div>has 3, not 6 items in it.<br><br>It is temping to think of a dictionary as a list of 6 things, but try to think of it as a set of 3 pairs, that go together.</div><br>Practice a bit more, and create a dictionary that maps a number to its square, for 1 to 5:<div>1 -&gt; 1</div><div>2 -&gt; 4</div><div>3 -&gt; 9</div><div>4 -&gt; 16</div><div>5 -&gt; 25</div><div><br></div><div>Dictionaries, like lists, can be printed with print().</div></br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/01 Dictionary basics/84041_04_code.step.py</p><hr><p><code>squares = __
print(squares)</code></p><hr><br><p>There are differences between lists and dictionaries too. Explore one in this exercise!</p></br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/01 Dictionary basics/84041_05_code.step.py</p><hr><p><code>list1 = [1,2,3]
list2 = [3,1,2]
assertEqual(list1, list2)
dict1 = {'one': 'uno', 'two': 'dos'}
dict2 = {'two': 'dos', 'one': 'uno'}
assertEqual(dict1, dict2)</code></p><hr><h3>02 Retrieving elements</h3>Accessing elements of a dictionary looks, syntactically, like accessing a list:<div><br></div><div><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}<br>one_in_spanish = babel_fish[1]                  &lt;-- this contains the word 'uno' </code></pre><br></div><div>But the meaning is a bit different. While in a list getting [1] means getting the first element, in a dictionary it means finding the value that is connected to the value 1.<br></div><div><br></div><div>That means for a dictionary, we can also encounter something like:<br><br></div><div><pre><code>babel_fish_reverse = {'uno':1, 'dos':2, 'tres' :3}<br>one_as_number = babel_fish_reverse['uno']      &lt;-- this contains the number 1 </code></pre></div><div><br></div><div>Explore it in the next step.</div><br>Practice retrieving information from a dictionary.</br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/02 Retrieving elements/86907_02_code.step.py</p><hr><p><code>double = {1: 2, 1.5:3, 2: 4, 3: 6}
assertEqual(__, double[1])
assertEqual(3, double[__])

half = {1 : 0.5, 2:1, 3:1.5}
assertEqual(__, half[2])
assertEqual(1.5, half[__])</code></p><hr><p>You have seen what dictionaries can do, that is: storing pairs of data:</p><p>1 --&gt; uno<br>2 --&gt; dos<br>3 --&gt; tres<br></p><p>These are called keys (1,2,3) and values ('uno', 'dos', 'tres'). We can access those separately.<br></p><p>Explore it in the next step.</p><p><br></p><br><br>Explore how to get keys and values from a dictionary.</br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/02 Retrieving elements/86907_04_code.step.py</p><hr><p><code>babel_fish = {1: 'één', 2: 'twee'}
assertEqual(__, len(babel_fish.keys()))
assertEqual(__, len(babel_fish.values()))
assertEqual(__, 1 in babel_fish.keys())
assertEqual(__, 2 in babel_fish.values())</code></p><hr><div>In the previous step we have seen the names for the two parts in a dictionary: keys and values.</div><div><br></div><div>1 --&gt; uno<br>2 --&gt; dos<br>3 --&gt; tres<br></div><div><br></div>These come in handy when you try to retrieve an element (a key) that does not exist. <br><br>Try it in the next step.<br><div><br></div><br><p>See what happens when we look for a missing key.</p><p>Run this code first to see what happens! Only fix the code after you have seen the error.</p></br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/02 Retrieving elements/86907_06_code.step.py</p><hr><p><code>silverware_in_Dutch = {'fork': 'vork', 'knife':'mes'}
lepel = silverware_in_Dutch['spoon']
assertEqual(lepel, 'lepel')</code></p><hr>In the previous step, you have seen this error message:<div><br></div><div><span class="image-wrapper"><img src="https://ucarecdn.com/9463d188-dd07-4d91-afaa-6edbdf925372/" title="Image: https://ucarecdn.com/9463d188-dd07-4d91-afaa-6edbdf925372/"></span><br></div><div>Sadly, the error is not very informative. It does not tell us that there is no spoon, or that the spoon was not found. <br>Instead we get a KeyError, with the key that was not found: 'spoon'.</div>There is a second way to obtain elements from a dictionary, which is the <code>get()</code>:<br><br><div><code><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}<br>two_in_spanish = babel_fish.get(2, 'Key not found in the dictionary') #&lt;-- results in 'dos'
four_in_spanish = babel_fish.get(4, 'Key not found in the dictionary') #&lt;-- results in 'Key not found in the dictionary'<br></code></pre> </code><br><code>get()</code> takes two arguments, the first one is the key we are looking for, and the second one is what is returned when the value is not found. That looks a bit nicer than an error message. Try it in the next step.<br><br><br></div><div><br></div><br></br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/02 Retrieving elements/86907_09_code.step.py</p><hr><p><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}
two_in_spanish = babel_fish.get(2, 'Key not found in the dictionary')
assertEqual(__,two_in_spanish)
four_in_spanish = babel_fish.get(4, 'Key not found in the dictionary') 
assertEqual(__,four_in_spanish)</code></p><hr><h3>03 Adding and updating elements</h3><p>In the previous lesson, we created a dictionary at once, with an initialization:</p><p></p><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}</code></pre><p></p><p>We can also add elements to an existing dictionary. Suppose we want to add 4, mapping to 'quatro'<br>Based on what we know from lists, you might think that it would be append. But it is not, it is update:</p><p></p><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}<br>babel_fish.update({4: 'quatro'})<span> </span></code></pre><p></p><p>Explore it in the next step. Also try to use append and see what happens.</p><br><p>Try to add a new key-value pair to a dictionary.</p><p>Also try to use append and see what happens.</p></br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/03 Adding and updating elements/84269_02_code.step.py</p><hr><p><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}
babel_fish.update({4: 'quatro'}) 
assertEqual(__, babel_fish[4])

babel_fish.append({4: 'quatro'})</code></p><hr><p>If you tried append in the previous step, you saw this error message:</p><p><img src="https://ucarecdn.com/3a48ea8c-dd2a-4ded-bf4f-c310f3558310/"></p><p><span>Contrary to some error messages we saw earlier, this is actually quite an informative message:</span><br></p><p><b>AttributeError: 'dict' object has no attribute 'append'</b><br></p><p>'dict' means dictionary, and Python here is telling us that something that is a dictionary does not have an attribute called append. Suppose you ever confuse a list and a dictionary (I still do after years of programming Python) this error message tells you that you have used the wrong operation.</p><p>The update operation not only adds elements, but also changes them.<br>Suppose our dictionary contains these items:</p><p></p><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}</code></pre><br>and we want to change the words to be Dutch, rather than Spanish. We could use:<br><p></p><p></p><pre><code>babel_fish.update({1: 'een'}) &lt;-- babel_fish[1] now contains een</code></pre> <br>Explore it in the next step<br><br><p></p><p><br></p><br><p>Explore updating a dictionary.</p></br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/03 Adding and updating elements/84269_05_code.step.py</p><hr><p><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}
babel_fish.update({1: __})
babel_fish.update({2: __})
babel_fish.update({__:'tres'})
assertEqual(babel_fish, {1: 'een', 2: 'twee', 3: 'drie'})</code></p><hr>In addition to updating with the update operation, dictionaries can also be added to and updated with rectangular brackets.<div>Explore it in the next step!</div><p>Like lists, dictionaries can be updated. For lists, we used insert:</p><div><br></div><pre><code><div></div>gandalf_says = ['you', 'will', 'pass']<br>gandalf_says[1] = 'shall'        &lt;-- gandalf_says now contains ['you', 'shall', 'pass']</code></pre><div><br></div><div>Dictionaries may be updated in a similar way. Explore it in the next assignment.</div><br><p></p><br><p>Updating dictionaries can be done by assigning to elements, just like in lists.</p></br><p>Code below is found in Python files/06 Chapter 1.7 - About Dictionaries/03 Adding and updating elements/84269_08_code.step.py</p><hr><p><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}
babel_fish[1] = __
babel_fish[2] = __
babel_fish[__] = 'drie'
babel_fish[__] = __
assertEqual(babel_fish, {1: 'een', 2: 'twee', 3: 'drie', 4: 'vier'})</code></p><hr><h2>07 Chapter 1.7 - About Writing and Reading Text</h2><h3>01 Printing text and numbers together</h3><p>In the exercises so far we have printed either numbers or text, like this:</p><p></p><pre><code>print(4)<br>print('Can I get a little more?')</code></pre> <br>But sometimes we want to print text and numbers together, like this:<p></p><p><b>The sensor of the EVA suit reports a pressure of 12 bar.</b></p><p>﻿Combining text and numbers is a bit more involved as you will learn in this section.<b><br></b></p><br>Explore printing text and numbers together.<div>Try what happens without str() around the number!</div></br><p>Code below is found in Python files/07 Chapter 1.7 - About Writing and Reading Text/01 Printing text and numbers together/83922_02_code.step.py</p><hr><p><code>winner = 65
string = 'And the winner is...:' + str(winner)
assertEqual(__, string)</code></p><hr>If you tried the code without str(), like this:<div><br></div><div><pre><code>string = 'And the winner is...:' + winner</code></pre><br><div>You saw this error message:<br></div><div><div><br></div><div><img alt="" src="https://ucarecdn.com/bb98e230-99f5-4bda-8f1f-b2262a4705d5/"></div><div><br></div><div>What happens here is that Python tries to add text <b>And the winner is...:</b> to a number: <b>65</b> in this case, stored in the variable winner.</div><div><br></div><div>Now Python is confused, because it does not know how to add numbers and text. It can add numbers, of course:</div><div><br></div><div><pre><code>sum = 1 + 3 &lt;-- sum now contains 4</code></pre><br>It can also add two strings (pieces of text)<br><br><pre><code>dylan = 'Robert' + ' Zimmerman' &lt;-- dylan now contains Robert Zimmerman</code></pre> </div><div>What we see here is that + can mean two things:</div><div><br></div><div><ol><li>adding numbers</li><li>concatenating strings</li></ol></div><div><br></div><div>When we print something like <b>And the winner is...: 65</b> we want to use the second meaning of +: glueing two strings together. We therefor need to change the number 65 in the text 65. To our human eye they look the same, but not to Python!</div><div><br></div><div>We use str() to convert a number to a string. This conversion is also called 'casting'.</div><div><br></div></div></div><p>There is an easier way of printing, which is<span> format. It can mix text and numbers without casting, i.e. without using str() around the number.</span></p><p><span>Explore it in the next step.</span><br></p><br><p>Try the format yourself!</p></br><p>Code below is found in Python files/07 Chapter 1.7 - About Writing and Reading Text/01 Printing text and numbers together/83922_05_code.step.py</p><hr><p><code>highest = 65
second_highest = 58
string = "The highest values measured are is {0} and {1}".format(highest, second_highest)
assertEqual(__, string)</code></p><hr><br><p>You can use the parameters in any order, and also multiple times within a string.</p><p>Try this below.</p></br><p>Code below is found in Python files/07 Chapter 1.7 - About Writing and Reading Text/01 Printing text and numbers together/83922_06_code.step.py</p><hr><p><code>winner = 65
second_highest = 58
runner_up = "The top 2 is {0} and {1}. I repeat... {0} then {1}!".format(winner, runner_up)
assertEqual(__, string)</code></p><hr><br><p>There are a few neat commands you can use on strings to make them look nicer. Try a few in this step.</p></br><p>Code below is found in Python files/07 Chapter 1.7 - About Writing and Reading Text/01 Printing text and numbers together/83922_07_code.step.py</p><hr><p><code>assertEqual(__, 'guido'.capitalize())
assertEqual(__, 'guido'.upper())
assertEqual(__, 'TimBot'.lower())
assertEqual(__, 'guido van rossum'.title())
assertEqual(__, 'ToTaLlY aWeSoMe'.swapcase())</code></p><hr><h3>02 Retrieving parts of a given text</h3>Sometimes you will want to print only part of a text. <div><br></div><div>For example when you are reading information from a file (which we will teach you about later!) and you read a file with <a rel="nofollow" href="https://www.kaggle.com/usgs/earthquake-database">earthquake data</a> which looks like this:</div><div><br></div><div><a href="https://ucarecdn.com/85a844bf-2299-4ba5-a726-5c4543c7a897/">https://ucarecdn.com/85a844bf-2299-4ba5-a726-5c4543c7a897/</a>﻿<br></div><div><img alt=""><br></div><div><br><div><div>Assume for now that we have stored the first line of data, separated by spaces, in a variable called line_1:<br></div><div><br></div><div>line_1 = "1/2/65
  13:44:18 19.246 145.616 131.6 6"</div><div><br></div></div></div><div>We would rather have a list, so we can easily process the data. Explore splitting in the next step.</div><br><p>Explore splitting in this step.</p></br><p>Code below is found in Python files/07 Chapter 1.7 - About Writing and Reading Text/02 Retrieving parts of a given text/84038_02_code.step.py</p><hr><p><code>line_1 = "1/2/65 13:44:18 19.246 145.616 131.6 6"
data = line_1.split()
assertEqual(__, data)</code></p><hr><br>Since data is now a list, we can access it like any list, using [].<div><br></div><div>Explore it yourself!</div></br><p>Code below is found in Python files/07 Chapter 1.7 - About Writing and Reading Text/02 Retrieving parts of a given text/84038_04_code.step.py</p><hr><p><code>line_1 = "1/2/65 13:44:18 19.246 145.616 131.6 6"
data = line_1.split()
assertEqual(__, data[5])
assertEqual('1/2/65', data[__])</code></p><hr>Sometimes you want to get a specific part of a string, since you know exactly what you are looking for.<div><br></div><div>For example, if your data is:</div><div><br></div><div>Type of Motor: 1 </div><div><br></div><div>You could retrieve just the last character of the text. Retrieving one character from a string works like retrieving one element from a list, with []:</div><div><br></div><div></div><pre><code><div>data = "Type of Motor: 1"</div><div>motor_type = data[15]        &lt;-- this now contains 1 (the 16th letter of the text, aka element 15)</div></code></pre><div></div><div><br></div><div>Note that spaces are characters, and are thus counted!</div><div><br></div><div>Explore it in the next step.</div><br><p>Try to retrieve the final element of the text data. </p><p>There are two ways to  do this! Do you remember this from the list exercises how you can get the final element in an easier way?</p></br><p>Code below is found in Python files/07 Chapter 1.7 - About Writing and Reading Text/02 Retrieving parts of a given text/84038_06_code.step.py</p><hr><p><code>data = "DNA Enzyme: A"
current_enzyme = data[__]
also_current_enzyme = data[__]
assertEqual(current_enzyme, also_current_enzyme)</code></p><hr><p>Like in lists, we can use slices [:] to retrieve multiple elements.</p><p>Remember how it worked for lists:</p><p></p><pre><code>colors = ['Black', 'White', 'Grey', 'Green', 'Pink']<br>grayscale = colors[0:3]</code></pre> <p><br>It works similar for strings, but beware to count the letters and not the words!</p><p></p><pre><code>data = "Angle of Motor: 187"<br>angle = data[16:18]             &lt;-- this now contains 187</code></pre> <p></p><p>Explore this in the next step.</p><br><p>Try to get the 240 from the variable data.</p><p>Again there are two ways of doing this, can you figure out which?</p></br><p>Code below is found in Python files/07 Chapter 1.7 - About Writing and Reading Text/02 Retrieving parts of a given text/84038_09_code.step.py</p><hr><p><code>data = "Red value: 240"
assertEqual(240, data[__:__])
assertEqual(240, data[__:__])</code></p><hr><h2>08 Chapter 1 Puzzle - Translating words & sentences</h2><h3>01 Step 1: Translating words</h3>Even though you only know a few Python commands, you can create a small program already!<div>In this exercise we will make a translation program with the commands we already know, step by step.</div><div><br></div><div>In the end, we will have a program that takes small calculations, like this:</div><div><br></div><div><b>1 + 1 = 2</b></div><div><br></div><div>and translates them into sentences in English, like this:</div><div><br></div><div><b>one plus one is two</b></div><br><p>Indeed, translation can be created with a dictionary. In this first step we create the dictionary and retrieve an item.</p><p>Can you finish the code?</p></br><p>Code below is found in Python files/08 Chapter 1 Puzzle - Translating words & sentences/01 Step 1: Translating words/86619_03_code.step.py</p><hr><p><code>calculations_to_letters = __ #<-- create the dictionary here
one_in_letters = __ #<-- loop up '1' here
print(one_in_letters)
plus_in_letters = __ #<-- loop up '+' here
print(plus_in_letters)</code></p><hr>In the next lesson we will translate the whole calculation.<h3>02 Step 2: Translating sentences</h3>We are working on a program that will translate<br><div><br></div><div><b>1 + 1 = 2</b></div><div><br></div><div>into:</div><div><br></div><div><b>one plus one = 2</b></div><div><br></div><div><b>Extra assignment: </b>Think about the steps that you would use to do this before the next puzzle.</div><div><br></div><br><p>Now that we know the steps, it is up to you to program them!</p><div>The skeleton of the program is there. Can you now do the rest?<br></div><br><p></p></br><p>Code below is found in Python files/08 Chapter 1 Puzzle - Translating words & sentences/02 Step 2: Translating sentences/86598_03_code.step.py</p><hr><p><code>calculations_to_letters = __ # <-- this is the dictionary
input = "2 + 2 = 6"
calculation_elements = input.split()
number_1 = calculation_elements[__]
#... here some lines need to be added!
word_0 = calculations_to_letters[number_1]



output = word_0 + __
assertEqual(output, "two plus two equals four")</code></p><hr><br><p>If you created the dictionary like me, you just included the elements needed for the calculation<b> 2 + 2 = 4</b></p><p></p><pre><code>calculations_to_letters = {'2':'two', '+': 'plus', '=':'equals', '4':'four'}</code></pre><p></p><p>Other letters are not needed anyway! But now, the program will try a few more secret calculations. You cannot see them, but they will be tried with your code. All numbers will be below 10.<br><br>For all these secret calculations, your program needs to return the right words, so the dictionary must contain more elements.</p></br><p>Code below is found in Python files/08 Chapter 1 Puzzle - Translating words & sentences/02 Step 2: Translating sentences/86598_04_code.step.py</p><hr><p><code>calculations_to_letters = {'2':'two', '+': 'plus', '=':'equals', '4':'four'}
input = input() #<--here the secret calculations are read
calculation_elements = input.split()
element_1 = calculation_elements[0]
word_1 = calculations_to_letters[element_1]

element_2 = calculation_elements[1]
word_2 = calculations_to_letters[element_2]

element_3 = calculation_elements[2]
word_3 = calculations_to_letters[element_3]

element_4 = calculation_elements[3]
word_4 = calculations_to_letters[element_4]

element_5 = calculation_elements[4]
word_5 = calculations_to_letters[element_5]

output = word_1 + ' ' + word_2 + ' ' + word_3 + ' ' + word_4 + ' ' + word_5

print(output) #<-- the output is printed and compared to the secret answers</code></p><hr><h2>09 Chapter 2.1 - About Control Flow</h2><h3>01 If statements</h3><p>In all exercises so far, all lines of Python that you typed, always were executed. </p><p></p><pre><code>temperature = 21                            #&lt;-- always happens<br>list_of_bands = ['U2', 'B52's', 'Boyz2Men'] #&lt;-- always happens<br>favorite_band = list_of_bands[2]            #&lt;-- always happens</code></pre><p></p><p><span>That sounds totally logical, but in this lesson, we will explore the if statement, which can cause lines to only be executed in certain situations.</span><br></p><p> </p><p>Code within an if statement consists of two parts, a condition and a body. Globally, it looks like this:</p><p></p><pre><code>if condition:      #&lt;-- the first line ends with a colon (:)<br>    body_line_1    #&lt;-- every line in the body needs to be indented (i.e. start with spaces)
    body_line_2 
</code></pre> <p><br>Let's first study the structure. The first line starts with if, then a condition and then a colon(:). <br>This colon is important, without it, the code will not run.</p><p>Then follows the body. It may consist of one or more line, but all lines need to start with <i>indentation</i>: either a tab character, or a number of spaces. In the examples, we use 4 spaces.</p><p><br></p><p>Now that we know the structure of the if, let's explore it's meaning. <br>The condition is something than can be True or False. In the next lesson, you will learn more about conditions and how they work.<br>For now, all conditions will be of the form </p><p></p><pre><code>x &lt; 5:</code></pre><p></p><p>This means, like in math, x is smaller than 5.</p><p>When the condition is true, the body will be executed. If not, it will be skipped entirely. </p><p></p><pre><code>if 3 &lt; 2:                      #&lt;-- 3 &lt; 2 is False, since 3 is not smaller than 2.<br>    print("I am not printed")  #&lt;-- all indented lines will be skipped
    print("Neither am !")      #&lt;-- all indented lines will be skipped</code></pre> <br><p></p><p></p><p></p><pre><code>if 2 &lt; 3:                      #&lt;-- 2 &lt; 3 is True, since 2 is indeed smaller than 3.<br>    print("I will be printed") #&lt;-- all indented lines will be executed
    print("So will !")         #&lt;-- all indented lines will be executed</code></pre><p></p><p>Explore it in the next step.<br></p><br><p>Change the temperature such that <b>Warm enough</b> will be printed.</p></br><p>Code below is found in Python files/09 Chapter 2.1 - About Control Flow/01 If statements/83787_04_code.step.py</p><hr><p><code>temperature = __
if temperature > 20:
    print('Warm enough')</code></p><hr><br>Change the temperature such that <b>﻿</b>nothing<b></b> will be printed.</br><p>Code below is found in Python files/09 Chapter 2.1 - About Control Flow/01 If statements/83787_05_code.step.py</p><hr><p><code>temperature = __
if temperature > 20:
    print('Warm enough')</code></p><hr><br><p>Beware, there are assignments in the body of the if statement now. <br>Can you figure out the result?</p></br><p>Code below is found in Python files/09 Chapter 2.1 - About Control Flow/01 If statements/83787_06_code.step.py</p><hr><p><code>result = ''
value = 12
if value < 5:
    result = 'small enough'
assertEqual(__, result)</code></p><hr><h3>02 If else statements</h3><p>An if statement can be combined with an else, like this:</p><p></p><pre><code>if 3 &lt; 2:                      &lt;-- 3 &lt; 2 is false<br>    print("I am not printed")  &lt;-- this line will be skipped
else:                          &lt;-- note that else too is followed by a colon(:)!
    print("I will be")         &lt;-- but this one will be executed</code></pre> <br><p></p><br>Try to solve this exercise.</br><p>Code below is found in Python files/09 Chapter 2.1 - About Control Flow/02 If else statements/83876_02_code.step.py</p><hr><p><code>course_code = 'TI3105TU'
if course_code == 'TI3105TU':
    result = 'yes!'
else:
    result = 'this is not the course you are looking for'
assertEqual(__, result)</code></p><hr><br><p>Try to solve this exercise.<br></p></br><p>Code below is found in Python files/09 Chapter 2.1 - About Control Flow/02 If else statements/83876_03_code.step.py</p><hr><p><code>course_code = 'TI3105TU'
if course_code != 'TI3105TU':
    result = 'oops, wrong course!'
else:
    result = 'I want to learn Python'
assertEqual(__, result)</code></p><hr>Sometimes you will want to check a number of options and respond accordingly. For example, whether a value is 1, 2 or 3. For this you can use an elif to test different conditions. It looks like the if-else structurally:<div><br></div><div><pre><code>if code == 0:                 <br>    print("code is zero")     &lt;-- this one will be executed when code is 0
elif code == 1:               &lt;-- note that elif too is followed by a colon(:)!
    print("code is one")      &lt;-- this one will be executed when code is 1
else:                          
    print("neither 0 nor 1")  &lt;-- this one will be executed when code is anything else then 0 or 1</code></pre> <br></div><div>You can use as many elif's as you want within a statement. </div><br>Explore elif in this step!</br><p>Code below is found in Python files/09 Chapter 2.1 - About Control Flow/02 If else statements/83876_05_code.step.py</p><hr><p><code>temperature = 5
if temperature < 0:
    result = 'subzero'
elif temperature == 0:
    result = 'zero'
else:
    result = 'nice and warm'
assertEqual(__, result)</code></p><hr><h3>03 If elif else</h3>Sometimes you want to check more than 2 options. This can be done with a bigger statement, the if elif else statement. It looks like an if with more options:<div><br></div><div><pre><code>if code &lt; 0:                       <br>    print('Sub zero')          #&lt;-- this line is executed when code is smaller than 0<br>elif code &gt; 0:                 #&lt;-- note elif too needs to be followed by a colon (:)<br>    print('Warm!')             #&lt;-- this line is executed when code is bigger than 0<br>else:<br>    print('Code must be 0')    #&lt;-- if code is not bigger than or smaller than 0, it must be zero<br></code></pre> <br></div><div>Try elif in the next step.</div><br><p>Explore the elif in the exercise.</p></br><p>Code below is found in Python files/09 Chapter 2.1 - About Control Flow/03 If elif else/84024_02_code.step.py</p><hr><p><code>temperature = 5
if temperature < 0:
    result = 'subzero'
elif temperature == 0:    
    result = 'zero'
else:
    result = 'nice and warm'
assertEqual(__, result)</code></p><hr><h2>10 Chapter 2.2 - About True and False</h2><h3>01 Comparing elements</h3>In previous lessons, we have compared elements simply with greater than (&gt;) and smaller than (&lt;). <div><br></div><div>For example, we have seen:<br><div><br></div><div></div><pre><code><div>if 2 &lt; 3:                        #&lt;-- 2 &lt; 3 is true<br>     print("I will be printed")  #&lt;-- all indented lines will be executed</div><div>     print("So will !")          #&lt;-- all indented lines will be executed</div></code></pre><div></div><div><br></div><div><br></div></div>In addition to &lt; and &gt; there are also ≥ (greater than or equal to) and ≤ (less than or equal to), but they are written a bit different than in math class. <div><br></div><div>Explore them in them next step.</div><br><p>Make the code print <b>No freeze!</b>﻿ when the temperature is 0 or more.<br><br>The temperature is a hidden value again.</p></br><p>Code below is found in Python files/10 Chapter 2.2 - About True and False/01 Comparing elements/87365_03_code.step.py</p><hr><p><code>if temperature >= __:
    print('No freeze!')</code></p><hr><h3>02 Equality and inequality</h3><p>In addition to checking is this an smaller or larger, we can also test if two things are exactly equal. For example:</p><p></p><pre><code>if name == 'Felienne':          #&lt;-- if name is equal to 'Felienne'<br> print('You are the teacher')<br>else <br> print('You are a student')</code></pre> <p><br>Note the double equal signs (==) here. They matter! !<br><br>Explore it in the next step.</p><br><p>Explore checking equality with ==.</p></br><p>Code below is found in Python files/10 Chapter 2.2 - About True and False/02 Equality and inequality/87366_02_code.step.py</p><hr><p><code>course_code = 'TI3105TU'
    if course_code == 'TI3105TU':
        result = 'yes!'
    else:
        result = 'this is not the course you are looking for'
assertEqual(__, result)</code></p><hr>We can also test if things are *not* equal to each other. In mathematics, we use ≠ for that. <div><br></div><div>For example: <span>4 </span><span>≠ 5 is True, while 5 </span><span>≠5 is False.</span><div><br></div></div><div>In Python ≠ is denoted as !=, like this:</div><div><br></div><div></div><pre><code><div>if 4 != 5:</div><div> print("Everything is fine")<br></div><div>else:</div><div> print("An unexpected error has occurred")</div></code></pre><div><br></div><div>Explore it in the next step.</div><br><p>Explore inequality with !=.</p></br><p>Code below is found in Python files/10 Chapter 2.2 - About True and False/02 Equality and inequality/87366_04_code.step.py</p><hr><p><code>course_code = 'TI3105TU'

if course_code != 'TI3105TU':
    result = 'oops, wrong course!'
else:
    result = 'I want to learn Python'
assertEqual(__, result)</code></p><hr>TODO: some interesting examples here and more practice<h3>03 Conditions</h3><p>In programming, a very important concept is the condition. </p><p>Secretly, you have seen a lot of conditions already.</p><p>For example, you saw:</p><div></div><pre><code><div>if 2 &lt; 3:                        #&lt;-- 2 &lt; 3 is true<br>     print("I will be printed")  </div><div>     print("So will !")          </div></code></pre><div></div><div><br></div><div>2 &lt; 3 here is a condition, which in this case is True. </div><div><br></div><div>Practise your skills in evaluating conditions in the next step.</div><br><p></p><div><span>Maybe you have noticed that we wrote that expressions evaluate to True rather than true. </span><span>We say 'it is True' rather than 'it is true' since True and False are Python commands.</span></div><div><br></div><div>We can print the results of conditions directly, resulting in True or False.<br></div><div>Explore it in the next step.</div><i></i>﻿<br><p>The result of a condition can be printed.</p><p>The code now prints <b>True</b> since the condition in the print() is True. In programming, this is most commonly called the condition 'evaluates to True'.</p><p>Can you make it print False by making the condition untrue, i.e. False.</p></br><p>Code below is found in Python files/10 Chapter 2.2 - About True and False/03 Conditions/87367_04_code.step.py</p><hr><p><code>print(2<3)</code></p><hr>True and False are Python commands, so they can also be used in code.<div><br></div><div>For example, we can write:</div><div><br></div><div></div><pre><code><div>if True:</div><div> result = "True is True"</div></code></pre><div><br></div><div>What will that print? Explore in the next step.</div><br><p>Where does a bear poop?</p></br><p>Code below is found in Python files/10 Chapter 2.2 - About True and False/03 Conditions/87367_06_code.step.py</p><hr><p><code>bear_poop_place = ""
if True:
    bear_poop_place = "woods"
assertEqual(__, bear_poop_place)</code></p><hr><br><p>Is ketchup a dessert?</p></br><p>Code below is found in Python files/10 Chapter 2.2 - About True and False/03 Conditions/87367_07_code.step.py</p><hr><p><code>dessert = "chocolate"

if False:
    dessert = "ketchup"
    assertEqual(__, dessert);</code></p><hr>So far, I guess, this was pretty reasonable, and what you would expect. <br>The next few evaluations to True or False are going to be a bit weird, beware!<h3>04 And and Or</h3>Generated lesson<h2>11 Chapter 2.3 - About For</h2><h3>01 For loops and lists</h3><p>Remember that we created a dictionary in the previous lessons? The code was something like:</p><p></p><pre><code>calculations_to_letters = {'2':'two', '+': 'plus', '=':'equals', '4':'four'}<br>input = "2 + 2 = 4"

calculation_elements = input.split()<br>element_1 = calculation_elements[0]<br>word_1 = calculations_to_letters[element_1]<br><br>element_2 = calculation_elements[1]<br>word_2 = calculations_to_letters[element_2]<br><br>element_3 = calculation_elements[2]<br>word_3 = calculations_to_letters[element_3]<br><br>element_4 = calculation_elements[3]<br>word_4 = calculations_to_letters[element_4]<br><br>element_5 = calculation_elements[4]<br>word_5 = calculations_to_letters[element_5]<br><br>output = word_1 + ' ' + word_2 + ' ' + word_3 + ' ' + word_4 + ' ' + word_5<br><br>print(output)</code></pre><br>This works well, but it is very long, and contains lots of repetition!<br><br>In this chapter, you will learn a new Python command that will reduce this program to about 5 lines and removes the similar lines.The first thing we need to know is how to work on multiple items in a list.<div><br>When we have items in a list, we can 'loop' over them using for. Like this:<br></div><div><div><br></div><div></div><pre><code><div>input = "I love programming and Python is very nice"<br></div>words = input.split()
for w in words:
    print(w)</code></pre> <div><br>This code will print all words in the sentence.</div><div><br></div><div>Explore it in the next step.</div></div><br>Change the code such that it prints all words in the sentence "I love programming and Python is very nice"</br><p>Code below is found in Python files/11 Chapter 2.3 - About For/01 For loops and lists/78679_03_code.step.py</p><hr><p><code>input = "I love programming Python is nice"
words = input.split()
for w in words:
    print(w)</code></p><hr>Note that like in the if statements of the previous lesson, four spaces are placed before the things inside the loop:<div><br></div><div><pre><code>input = "I love programming and Python is nice"<br>words = input.split()<br>for w in words:<br>    print(w)   #&lt;-- starts with four spaces!</code></pre> </div><div>There can be multiple lines starting with spaces, all these lines will be executed for all elements of the loop. For example</div><div><br></div><div><div><br></div><div><pre><code>input = "I love programming and Python is nice"<br>words = input.split()<br>for w in words:
    uppercase_w = w.capitalize() #&lt;-- starts with four spaces!<br>    print(uppercase_w)           #&lt;-- starts with four spaces!</code></pre></div><br></div><div>Now, all words are capitalized and then printed.</div><div><br></div><div>All lines that start with spaces together are called the 'body' of the loop.</div><div>Explore this in the next step.</div><div><br><br></div><br><div>Can you print all words in the sentence "I love programming and Python is very nice" but capitalized? </div><div><br></div></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/01 For loops and lists/78679_05_code.step.py</p><hr><p><code>input = "I love programming and Python is nice"
words = input.split()
for w in words:
    __    
    print(w)</code></p><hr><h3>02 For loops with numbers</h3>In the previous step, we have done something for all elements in a list, like this:<div><br></div><div></div><pre><code><div>albums = ['Rumours', 'Tango in the night', 'English Rose']</div><div>for a in albums:</div><div>   print("I love " + a)</div></code></pre><div><br></div><div>But often we also want to repeat something a fixed number of times, like this:</div><div><br></div><div></div><pre><code><div>for i in range(0, 3):</div><div>    print('Hooray')</div></code></pre><div></div><div><br></div><div>Explore it in the next step.</div><br><p>Use a fixed number of iterations to print <b>All you need is love </b>﻿three times.</p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/02 For loops with numbers/86911_02_code.step.py</p><hr><p><code>for i in range(0,__):
    print(__)</code></p><hr><p>Remember that the 0 at the start of a range is optional. So you can also use:</p><p><span></span></p><pre><code><span>for i in range(3):<br></span><span>    print('Hooray')</span></code></pre><span></span><p></p>Remember to pay attention to what is in out outside of the body of the loop. Inside the body will be executed in each iteration of the loop. Outside it, only once, after the loop has ended.<div><br></div><div>Explore it in the next step.</div><br><p>Use a fixed number of iterations to print <b>All you need is love </b>three times, followed by <b>Love is all you need</b>, once.<br></p><p>The code is wrong now, but run it first to see what happens!</p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/02 For loops with numbers/86911_05_code.step.py</p><hr><p><code>for i in range(3):
    print('All you need is love')
    print('Love is all you need')</code></p><hr><h3>03 Accumulating to new lists and better translation</h3>A common pattern is working with loops is to start with an empty list, and add items to that list, based on a calculation in the loop.<div><br></div><div>For example, if we want to create a new sentence with capitalized words (rather than printing each item), we would do it like this:</div><div><br></div><div><pre><code>input = "I love programming and Python is nice"
output = '' #&lt;-- we start with an empty list as result<br><div><br></div>words = input.split() 
for w in words:
   output.append(w.capitalize())

print(output)</code></pre> </div><div><br>Explore this in the next step.</div><br><p class="wysiwyg-text-align-left">Translate all words in the sentence "I love programming and Python is very nice"  to uppercase and print the result, by starting with an empty list and appending translated elements to the resulting list.</p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/03 Accumulating to new lists and better translation/86912_02_code.step.py</p><hr><p><code>input = "I love programming and Python is nice"
output = [] #<-- we start with an empty list as result
words = input.split() 
for w in words:
   output.__(w.capitalize())
print(output)</code></p><hr><br>Remember that, if we want to get a nice sentence from the list, we can use ' '.join(list).<div><br></div><div>Now print the capitalized sentence "I Love Programming And Python Is Nice".<br><div><br></div></div></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/03 Accumulating to new lists and better translation/86912_03_code.step.py</p><hr><p><code>input = "I love programming and Python is nice"
output = [] #<-- we start with an empty list as result
words = input.split() 
for w in words:
   output.append(w.capitalize())
print(__)</code></p><hr>You should now be able to transform the long, duplicated code from the previous week into something nice and short. Use the building blocks you have learned in this lesson.<div><br></div><div>Try to improve this code in the next step, using a for, starting with an empty list and a ' '.join.</div><div><br></div><div><pre><code>calculations_to_letters = {'2':'two', '+': 'plus', '=':'equals', '4':'four'}<br>input = "2 + 2 = 4"

calculation_elements = input.split()<br>element_1 = calculation_elements[0]<br>word_1 = calculations_to_letters[element_1]<br><br>element_2 = calculation_elements[1]<br>word_2 = calculations_to_letters[element_2]<br><br>element_3 = calculation_elements[2]<br>word_3 = calculations_to_letters[element_3]<br><br>element_4 = calculation_elements[3]<br>word_4 = calculations_to_letters[element_4]<br><br>element_5 = calculation_elements[4]<br>word_5 = calculations_to_letters[element_5]<br><br>output = word_1 + ' ' + word_2 + ' ' + word_3 + ' ' + word_4 + ' ' + word_5<br><br>print(output)</code></pre> <br></div><br>For reference, here is the original code:<div><br></div><div><pre><code>calculations_to_letters = {'2':'two', '+': 'plus', '=':'equals', '4':'four'}<br>input = "2 + 2 = 4"

calculation_elements = input.split()<br>element_1 = calculation_elements[0]<br>word_1 = calculations_to_letters[element_1]<br><br>element_2 = calculation_elements[1]<br>word_2 = calculations_to_letters[element_2]<br><br>element_3 = calculation_elements[2]<br>word_3 = calculations_to_letters[element_3]<br><br>element_4 = calculation_elements[3]<br>word_4 = calculations_to_letters[element_4]<br><br>element_5 = calculation_elements[4]<br>word_5 = calculations_to_letters[element_5]<br><br>output = word_1 + ' ' + word_2 + ' ' + word_3 + ' ' + word_4 + ' ' + word_5<br><br>print(output)</code></pre> <br></div><div>Can you do it with just 10 lines?</div></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/03 Accumulating to new lists and better translation/86912_05_code.step.py</p><hr><p><code>calculations_to_letters = {'2':'two', '+': 'plus', '=':'equals', '4':'four'}
input = "2 + 2 = 4"

calculation_elements = input.split()
output = __
for i in __:
    word = calculations_to_letters[__]
    __ #<-- do something with word here.

print(output)</code></p><hr><h3>04 Continue</h3>When iteration over a list, or over a range of numbers, sometimes you will want to skip a certain number. For example, if we have a list of sensor values:<div><br></div><div><pre><code>saturation = [2, 5, -1, 41, 21, 9, -5]</code></pre><br></div><div><span>We know values below zero are measurement errors, and we should not print them.</span><br></div><div><br></div><div>We can skip them with a simple if, as we will see in the next step, but further in the lesson we will learn a more elaborate way too.</div><br><p>Print only the positive values in the list saturation using a combination of if and for.</p><p>Note that the if is inside the body, and the if itself uses indentation too, so there are two levels of indentation in this program!</p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/04 Continue/86940_02_code.step.py</p><hr><p><code>saturation = [2, 5, -1, 41, 21, 9, -5]
for s in saturation:
    if __ __ __:
        print(s)</code></p><hr><div>If we want to print only the positive numbers in a list, we can use an if, like you just saw in the previous step:</div><div><br></div><pre><code>saturation = [2, 5, -1, 41, 21, 9, -5]<br>for s in saturation:<br>    if s &gt; 0:<br>        print(s)</code></pre><div><br>But we could also use a continue statement. A continue skips an item of the list, under a certain condition. <br>Code equivalent to the code above is:</div><div><br></div><div></div><pre><code><div>saturation = [2, 5, -1, 41, 21, 9, -5]<br>for s in saturation:<br>    if s &lt;= 0:<br>       continue</div><div>    print(s)</div></code></pre><div><br></div><div>Continue can be a bit tricky, so practice with it in the next steps. I personally read continue as 'skip'.</div><br><br><div><b></b>Print all numbers in the list, <i>except for</i> the numbers above 20.<b></b></div></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/04 Continue/86940_04_code.step.py</p><hr><p><code>saturation = [2, 5, -1, 41, 21, 9, -5]
for s in saturation:
    if __ __ __:
        continue
    print(s)</code></p><hr><br><p>Print all bases in the DNA sequence that are not '-', those represent measurement errors.</p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/04 Continue/86940_05_code.step.py</p><hr><p><code>sequence = ['a', 'c', 'c', 'g', '-', 't' , 'g', '-', 't', 'a', 'g']
for base in sequence:
    if __ __ __:
        continue
    print(__)</code></p><hr><span class="wysiwyg-color-red">TODO: before this I should ask a few what is the same quetions!</span><div><br></div><div>These two blocks of code do the exact same thing:</div><div><div><br></div><pre><code>saturation = [2, 5, -1, 41, 21, 9, -5]<br>for s in saturation:<br>    if s &gt; 0:<br>        print(s)</code></pre><div><br>But we could also use a continue statement. A continue skips an item of the list, under a certain condition. <br>Code equivalent to the code above is:</div><div><br></div><div></div><pre><code><div>saturation = [2, 5, -1, 41, 21, 9, -5]<br>for s in saturation:<br>    if s &lt;= 0:<br>       continue</div><div>    print(s)</div></code></pre><div></div><br></div><div><span>Whether you use the one or the other is somewhat a matter of taste.</span><br></div><div><br>People that prefer the if, argue:</div><div><ul><li>if is used in many places, so it is easier to read.</li><li>the focus is on when to do something with the item in the list (print in the example) since the condition expresses when to do something (if an item is bigger than 0, in the example).</li></ul></div><div><br></div><div>People that like continue argue:</div><div><ul><li>the thing you do (print in the example) is nested less deep, making it easier to find. <br></li><li>the focus is on when to skip an item, making it easier to detect when something is wrong.</li></ul></div><div><br></div><div>As with natural language, where people debate whether or not to use the Oxford comma or the passive voice, in programming there are also opinions on what to use. We will see a lot more of these disagreements later in the lessons.</div><div><br></div><h3>05 Break</h3>In the previous step we have skipped some elements of a list, based on a condition:<div><br></div><div><pre><code>sequence = ['a', 'c', 'c', 'g', '-', 't' , 'g', '-', 't', 'a', 'g']<br>for base in sequence:<br>    if base == '-':<br>        continue</code></pre> </div><div>Sometimes however, we want to stop a loop entirely is something happens.</div><div><br></div><div>For example, analyzing data from a temperature monitoring system, printing the values. But when then temperature drops below 0, we want to stop reading values since we know a that point the experiment is failed.</div><div><br></div><div>For this, we can use a break, that stops a loop based on a condition.</div><div>Explore it in the next step.</div><br><p>Print the values until the temperature drops below 0.</p><p><br></p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/05 Break/87230_02_code.step.py</p><hr><p><code>temperatures = [2, 1, 5, 7, -1, 3, 7, 9, 10]
for t in temperatures:
    if t __ __:
        break
    print(__)</code></p><hr><h3>06 Accumulating to numbers</h3><p>Before, we saw the pattern of doing something with list items on all elements of a list, to create a new list, like:</p><p>['I', 'love', 'programming'] -&gt; ['I', 'Love', 'Programming']<br>or<br>['2', '+', '3'] -&gt; ['two', 'plus', 'three']</p><p>Another common pattern is to reduce a list to one number, for example, the number of items in a list, of the average of the list, or the maximum. </p><p></p><div>We will explore these in the next steps.</div><br><p></p><br><p></p><p>Similar to the pattern where we start with an empty list, we can also start with 0 and add values to the 'accumulator'. In the example, the accumulator is called sum.<br>What do we need to add to sum to get the sum of all numbers in the list (108)?</p><p></p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/06 Accumulating to numbers/87231_03_code.step.py</p><hr><p><code>numbers = [4, 8, 15, 16, 23, 42]
sum = 0
for n in numbers:
    sum = sum + __
print(sum)</code></p><hr><br><p>We now want to count the number of items in the list (6). What do we need to add to the accumulator now?</p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/06 Accumulating to numbers/87231_04_code.step.py</p><hr><p><code>numbers = [4, 8, 15, 16, 23, 42]
count = 0
for n in numbers:
    count = count + __
print(count)</code></p><hr><br><p>Now the average (18). </p><p>Can you calculate it, using the two accumulators of the previous steps?</p></br><p>Code below is found in Python files/11 Chapter 2.3 - About For/06 Accumulating to numbers/87231_05_code.step.py</p><hr><p><code>numbers = [4, 8, 15, 16, 23, 42]
average = 0
count = 0
sum = 0
for n in numbers:
    count = __
    sum = __

print(average)</code></p><hr><h2>12 Chapter 2.4 - About While</h2><h3>01 While loops</h3>In previous lessons we have seen 'for loops'. We use a for loop when we know, upfront, how many iterations are needed.<div><br></div><div>When looping over a list with for, we know how many steps we need to take: the number of items in the list.<br>For example, in this code:</div><div><br><pre><code>sequence = ['a', 'c', 'c', 'g']<br>for base in sequence:<br>    print(base)</code></pre> <br>The loop will be executed 4 times, thus, in this case, 4 things will be printed.</div><div><br></div><div>Sometimes, you do not know how many times a loop will be executed. In that case, you can use a different form of loop, the while loop. </div><div><div><div><span>Another form of a loop is the while loop. It looks different from a for loop, since it starts with a condition:</span><br></div></div></div><div><pre><code>while times &lt; 4:        #&lt;-- the loop will run while this is true
    print("Hello!")     #&lt;-- like in a for loop, all indented lines will be executed</code></pre><br></div><div>This first line indicated under what condition the loop will continue. In this case, when the variable times is smaller than 4.</div><div>That means we need to create this variable before the loop starts:</div><div><br></div><div></div><pre><code><div>times = 0</div><div>while times &lt; 4:        #&lt;-- the loop will run while this is true </div><div>    print("Hello!")     #&lt;-- like in a for loop, all indented lines will be executed</div></code></pre><div><br></div><div>Try running this code in the next step and see what happens....!</div><div><br></div><div><br></div><div><br><div><br><br></div></div><br>Execute the while loop and see what happens. </br><p>Code below is found in Python files/12 Chapter 2.4 - About While/01 While loops/87235_03_code.step.py</p><hr><p><code>times = 0
while times < 4:    #<-- the loop will run while this is true
    print("Hello") #<-- like in a for loop, all indented lines will be executed</code></p><hr><p>You have just seen your first 'overflow' error.</p><p><img alt="" src="https://ucarecdn.com/ba002c49-d986-4bde-8f96-119c6fec5ab2/" title="Image: https://ucarecdn.com/ba002c49-d986-4bde-8f96-119c6fec5ab2/"><br>The code stopped after a while, since the time limit on the exercise was passed and nothing happened.</p><p>This is a very common error, that you will probably make often in your programming life. I guess you have understood what went wrong.</p><p></p><pre><code>times = 0<br>while times &lt; 4:    #&lt;-- the loop will run while this is true<br>    print("Hello!") #&lt;-- like in a for loop, all indented lines will be executed</code></pre> <br>In the program, times is never changed! So it stays 0 and the loop never ends. We need to change times in the loop.<br>That is why while loops often look like this:<p></p><p></p><pre><code>times = 0<br>while times &lt; 4:    #&lt;-- the loop will run while this is true<br>    print("Hello!") #&lt;-- like in a for loop, all indented lines will be executed<br>    times = times + 1</code></pre> <p></p><p>Try this loop in the next step.</p><br><p>Print <b>Hello!</b> 4 times with a while loop.</p></br><p>Code below is found in Python files/12 Chapter 2.4 - About While/01 While loops/87235_06_code.step.py</p><hr><p><code>times = 0
while times < 4:    #<-- the loop will run while this is true
    print("Hello!") #<-- like in a for loop, all indented lines will be executed
    times = times + 1</code></p><hr><h3>02 While and for</h3><p>In the last lesson we saw while loops for the first time. <br>All for loops can be written as while loops*. For example the loop we have jus seen in the last step</p><p></p><pre><code>times = 0<br>while times &lt; 4:    #&lt;-- the loop will run while this is true<br>    print("Hello!") #&lt;-- like in a for loop, all indented lines will be executed<br>    times = times + 1</code></pre><p><br>Is equivalent to this for loop:</p><p></p><pre><code>for times in range(0,4):<br>    print("Hello!") </code></pre> <p></p><p></p><br><p></p><p>* We will see later that the reverse is not true. As an extra exercise you can think of a while loop already that cannot be translated to a for loop.</p><br>Print <b>I am in a loop!</b> 5 times using a for loop.</br><p>Code below is found in Python files/12 Chapter 2.4 - About While/02 While and for/87361_02_code.step.py</p><hr><p><code>for times in __:     
    print("I am in a loop!")</code></p><hr><br>Print <b>I am in a loop!</b> 5 times using a while loop.</br><p>Code below is found in Python files/12 Chapter 2.4 - About While/02 While and for/87361_03_code.step.py</p><hr><p><code>times = 0
while times < __:             #<-- the loop will run while this is true
    print("I am in a loop!") 
    times = __</code></p><hr><p class="wysiwyg-text-align-left"></p><p>Now of to loops that we cannot express with a for!</p><p>Imagine we are playing a very simple guessing game. We simple keep trying random values between 0 and 10 until we hit the answer (7) in this case.</p><p>How often will the program below run? Can we know up front?</p><p></p><pre><code><p>secret_value = 7                      #&lt;-- the secret value (not so secret in this case of course)<br>guess = 1                             #&lt;-- the first guess we try<br>while secret_value != guess:          #&lt;-- while we have not correctly guessed the answer<br>    guess = random.randint(1,10)      #&lt;-- try a new guess between 1 and 10<br>    print('That was one guess')
print("The secret number is... ", guess)
</p></code></pre><br><p></p><div>If you have no clue, you ca try the code in the next step!</div><br><p>Here is the code that guesses a random number until it finds 7. Run the code to find out what it does.</p><p>To pass the test, simply print the secret number once.<br><br></p></br><p>Code below is found in Python files/12 Chapter 2.4 - About While/02 While and for/87361_05_code.step.py</p><hr><p><code>secret_value = 7 #<-- the secret value (not so secret in this case of course)
guess = 1 #<-- the first guess we try
while secret_value != guess: #<-- while we have not correctly guessed the answer
    guess = random.randint(1,10) #<-- try a new guess between 1 and 10
    print('That was one guess')
print("The secret number is... ", guess)</code></p><hr>You now know about for and while loops. In general people prefer to use for loops where possible, and while loops only when a for loop is not possible, but sometimes while loops are also used as replacement for for loops.<div><br></div><div>In this weeks assignment you will think about for and while loops in a problem of your choosing!</div><h2>13 Chapter 2.5 - About loop conditions</h2><h3>01 Consuming lists</h3>On the lessons before, we have looped over lists, leaving the lists "in tact".<div><br></div><div>After iterating over a list, the list itself is still the same.</div><div>Verify this in the next step. </div><div><br></div><br><p>Ensure that the list words is unchanged after the loop.</p></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/01 Consuming lists/87646_02_code.step.py</p><hr><p><code>input = "I love programming and Python is very nice"
words = input.split()
for w in words:
    print(w)
assertEqual(__,words)</code></p><hr>There are other forms of looping too, that 'consume' the list. That means, the list is shortened step by step, and one element is peeled of.<div>An example of such a command is pop().<br></div><div><br></div><div>Beware, pop() removes the <b>last</b> element of the list!</div><div><br> We first show it without a loop:</div><div><br></div><div><div><pre><code>stack = [1, 2, 3, 4]<br>lucky_number = stack.pop()    #&lt;-- pop gets the last element (4) and also removes it<br>print(lucky_number)           #&lt;-- lucky_number now contains 4<br>print(stack)                  #&lt;-- stack now contains [1, 2, 3]<br></code></pre><br><div>Explore this in the next step.</div><div><br></div><br><br></div></div><br><p>Explore the pop() function.</p></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/01 Consuming lists/87646_04_code.step.py</p><hr><p><code>primes = [2, 3, 5, 7, 11]
last_prime = primes.pop()
assertEqual(__, last_prime)
assertEqual(__, primes)</code></p><hr><p></p><p>With a pop() function, we can also loop. <br></p><p>We could use code like this:</p><p></p><pre><code>list = [2, 6, 8, 12, 19, 5]
while ___:<br>    item = list.pop()
    print(item)
</code></pre> <p></p><p>When would the loop end? Think about it in the next step.</p><br><p></p><br><p>Finish the loop so all elements are printed. </p><p>Note: there are different ways of doing this! In the nest step you can try multiple ways.</p></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/01 Consuming lists/87646_07_code.step.py</p><hr><p><code>list = [2, 6, 8, 12, 19, 5]
while ___:
    item = list.pop()
    print(item)</code></p><hr><br><p>Now try to use tow different ways.</p></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/01 Consuming lists/87646_08_code.step.py</p><hr><p><code>even = [2, 4, 6, 8, 10, 12]
while ___:
    item = even.pop()
    print(item)

odd = [1, 3, 5, 7, 9, 11]
while ___:
    item = odd.pop()
    print(item)</code></p><hr>The two options we have are:<div><br></div><div>while lijst != []:<br></div><div><br></div><div>and</div><div><br></div><div>while len(lijst) == 0:<br></div><div><br></div><div>Which one do you think is better, and why? </div><h3>02 While len(list)</h3>So far, the True and False statements we have seen were somewhat predictable.<div><br></div><div>The results of this code are not really surprising:</div><div><br></div><div></div><pre><code><div>temperature = 20</div><div>if temperature &gt; 25:</div><div> print("warm!")</div></code></pre><div><br></div><div>However, there are some weird cases of conditions that we will learn about in this lesson.</div><div><br></div><br>And what about 1. Is it True or False?<div><br></div><div><br></div></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/02 While len(list)/87647_03_code.step.py</p><hr><p><code>dessert = "chocolate"

if 1:
    dessert = "dubbelvla"

assertEqual(__, dessert)</code></p><hr><br>And what about other numbers? Try a few!<div><br></div><div>Are they True or False?<div><br></div><div><br></div></div></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/02 While len(list)/87647_04_code.step.py</p><hr><p><code>dessert = "pudding"

if __:
    dessert = "fruit cake"

if __:
    dessert = "cheese cake"

if __:
    dessert = "lava cake"

assertEqual(__, dessert)</code></p><hr><p>Yes, you have learned that 0, when used in a condition is False, and that all other numbers are True. Even numbers below 0 are True.</p><p>Now that is a bit weird! There are also programming languages that do not even allow to write something like<br><br></p><pre><code>if 5:<br>   print("5 is True")</code></pre> <br><span>Why would Python be designed like this? Well, it allows us to make loop conditions shorter! And Python programmers love shorter commands.</span><p></p><p>For example when popping a list. We want to repeat that until the length of the list is 0, and we thus have seen all elements.</p><p>We have seen such code before, like this:</p><p></p><pre><code>while len(list) != 0:        #&lt;-- True while the list is not empty, and the length thus is longer than 0<br>    item = list.pop()<br>    print(item)</code></pre> <br><span>Now, we can rewrite it, into this:</span><p></p><p></p><pre><code>while len(list):             #&lt;-- True while the list is not empty, and the length thus is longer than 0<br>    item = list.pop()<br>    print(item)</code></pre> <br>That second code block does the same, since len(list) results in a number not zero when the list is not empty.<p></p><p>Weird, but useful! </p><p>Verify that these things are indeed the same in the next block.</p><br><p>Print the elements of [5, 6, 7, 8] twice, in different ways. </p></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/02 While len(list)/87647_07_code.step.py</p><hr><p><code>steps = [5, 6, 7, 8]
while len(__) != 0: #<-- True while the list is not empty, and the length thus is longer than 0   
    steps = list.pop()
    print(item)

steps = [5, 6, 7, 8]
while len(__):      #<-- True while the list is not empty, and the length thus is longer than 0    
    steps = list.pop()
    print(item)</code></p><hr><p>In the next lesson, we will see a similar weird evaluation to True/False.</p><h3>03 While list:</h3>So 0 evaluated to False, and all other numbers to True.<div><br></div><div>What would happen if we try to evaluate a list...?</div><div><br></div><div>See for yourself in the next step.</div><br><p>What would [] be? True or False?</p></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/03 While list:/87706_03_code.step.py</p><hr><p><code>dessert = "pie"

if []:
    dessert = "banana split"

assertEquals(__, dessert);</code></p><hr><br><p>And what would other lists be? Try a few!<br></p></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/03 While list:/87706_04_code.step.py</p><hr><p><code>dessert = "pudding"

if []:
    dessert = "apple pie"

if []:
    dessert = "tarte tartin"

if []:
    dessert = "steak pie"</code></p><hr>Indeed, all lists are True, except the empty list, which is False. <div><br></div><div>I guess by now you understand why... it is the same reason that 0 is False and other numbers are True. To shorten a loop over a list.</div><div><br></div><div>How can we shorten this?</div><div><br></div><div><pre><code>odd = [1, 3, 5, 7, 9, 11]<br>while odd != []:<br>    item = odd.pop()<br>    print(item)</code></pre> <br></div><div>Try it in the next step.</div><br><p>Change line 2 such that the loop prints all numbers again.</p><p>But... do not use <b>while odd != []:</b>!<br></p><p>It must be as short as possible!</p></br><p>Code below is found in Python files/13 Chapter 2.5 - About loop conditions/03 While list:/87706_08_code.step.py</p><hr><p><code>odd = [1, 3, 5, 7, 9, 11]
while odd == []:
    item = odd.pop()
    print(item)</code></p><hr>We have learned in this lesson and the previous one, that we can loop over lists with very short statements:<div><br></div><div><pre><code>while len(list): </code></pre><br></div><div><span>and</span><br></div><div><br></div><div><pre><code>while(list)</code></pre><br></div><div><span>Where possible, Python programmers prefer this over:</span><br></div><div><br></div><div><div><pre><code>while lijst != []:</code></pre></div><div><br></div><div>and</div><div><br></div><div><pre><code>while len(lijst) == 0:</code></pre><br></div><br></div><h2>14 Chapter 2 Puzzle - For and While loops</h2><h3>01 Step 1: For loops</h3>Generated lesson<h3>02 Step 2: While loops</h3>Generated lesson<h2>15 Chapter 3.1 - About Tuples</h2><h3>01 Creating and updating tuples</h3><p>So far, we have seen a number of different types in Python.</p><p></p><ul><li>Simple types for single items: int, float and string<br></li><li>Compound types that consist of multiple items: list and dictionary</li></ul><p>The elements of compound types each have their own datatypes. For example, we can have a list of integers or a dictionary of floating point keys and integer items.</p><p>In this lesson, you will see a new compound type: the tuple.</p><p></p><p>Tuples, like lists, consist of multiple items. They are create with round brackets () rather than [] for lists or {} for dictionaries. This creates a tuples of the numbers 1, 2 and 3.</p><p></p><pre><code>count_of_three = (1, 2, 3)</code></pre><p></p><p>In many ways, tuples are like lists. <span>For example, element retrieval works the same. <br><br>Explore it in the next step.</span></p><br><p>Retrieve an element from a tuple.</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/01 Creating and updating tuples/87801_03_code.step.py</p><hr><p><code>count_of_three = (1, 2, 3)
assertEqual(__, count_of_three[2])</code></p><hr><p>But, there are also differences between lists and tuples. The most important difference is that tuples cannot be changed!</p><p>That is strange right?<span> Try it in the next step.</span></p><br><p>Try the code... What happens when we try to edit an item?</p><p>To pass the test, simply remove line 2, which prints the original tuple.</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/01 Creating and updating tuples/87801_05_code.step.py</p><hr><p><code>count_of_three =  (1, 2, 3)
count_of_three[2] = 'two'
print(count_of_three)</code></p><hr>When you try to change an element, you get a type error:<div><br></div><div><img alt="" src="https://ucarecdn.com/b8e2d711-9de8-4482-8044-3b9f7e2ffbee/" title="Image: https://ucarecdn.com/b8e2d711-9de8-4482-8044-3b9f7e2ffbee/"><br><br></div><br><p>Something similar happens when we try to add an element.</p><p>Try it! <span>What happens when we try to append an item?</span></p><p></p><p>To pass the test, again remove line 2, which prints the original tuple.</p><br><p></p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/01 Creating and updating tuples/87801_07_code.step.py</p><hr><p><code>count_of_three =  (1, 2, 3)
count_of_three.append('two')
print(count_of_three)</code></p><hr>We get a similar error, since tuple has no append:<br><br><div><img src="https://ucarecdn.com/8266b592-0594-4836-800e-6f89f95b8235/" title="Image: https://ucarecdn.com/8266b592-0594-4836-800e-6f89f95b8235/"><br></div>So, when you are modeling problem later, and you know something will not change, using a tuple is better.<div>That way, Python will remind you that changes cannot be made.</div><h3>02 Some unexpected tuple things</h3>Generated lesson<br><p>Try to create a tuple with one element in it.</p><div>  </div><p></p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/02 Some unexpected tuple things/87802_02_code.step.py</p><hr><p><code>number_one = 1
assertEqual(__, type(number_one))

am_I_a_tuple = (1)
assertEqual(__, type(am_I_a_tuple))

or_am_I = (1,)
assertEqual(__, type(or_am_I))

tup1e = ("Imma tuple", )
assertEqual(__, type(tuple))</code></p><hr><br><p>What happens when we create a tuple from a string?</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/02 Some unexpected tuple things/87802_03_code.step.py</p><hr><p><code>suprise = tuple("Surprise!")
assertEqual(__, suprise)</code></p><hr><br><p>There are two ways to create an empty tuple. </p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/02 Some unexpected tuple things/87802_04_code.step.py</p><hr><p><code>sssertEqual(__ , ())
assertEqual(__ , tuple()) #Sometimes less confusing</code></p><hr><h3>03 The culture of tuples</h3>Before we explained that when data is not mutable (i.e. it should not change) you use a tuple instead of a list. This is a technical decision, since you really cannot change a tuple, Python will not let you.<div><br></div><div>There is a second reason to use a tuple, is that the elements are not of the same type.</div><div><br></div><div>So here you'd use a list, since all elements are integers:</div><div><br></div><div><pre><code>temperature = [21, 19, 20, 23, 10, 11]</code></pre><br></div><div>While here you use a tuple, since the elements are strings and integers mixed:</div><div><br></div><div><pre><code>carl = ('Carl', 'McAdams', 31)</code></pre><br></div><div><span>This is not a technical reason, because you can create a list with heterogenous items, and a tuple with homogenous ones. <br><br>But in general in the Python community, this is not done. </span><br></div><p>The situation gets even a bit more tricky! If we are deciding to use a list or a tuple, we are not only looking at the datatype, but also at the intent.</p><p>For example, it we store longitude and latitude, which both are floating point numbers, many people would still use a tuple, since they represent different sort of numbers. A good rule of thumb is that when the elements together from one item: a date, a location, a unique code, you use a tuple. </p><p></p><pre><code>address = ('Mekelweg', '4', '2628CD', 'Delft')</code></pre><p></p><p>When the items are all similar and stored in a collection, you use a list. <br><br>For example for a list of measurements:</p><p></p><pre><code>temperature = [20, 19, 0, 5, 15]</code></pre><p></p><p>This is not always black and white, and as many other things, programmers sometimes debate when to use which.</p><h3>04 Nesting tuples</h3>A common use case for tuples is to nest tuples, i.e. to create tuples of tuples, to create more complex structures.<div>Explore this in the next step.</div><br><p>What does a nested tuple look like?</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/04 Nesting tuples/87808_02_code.step.py</p><hr><p><code>lat = (37, 14, 6, 'N')
lon = (115, 48, 40, 'W')
place = ('Area 51', lat, lon)
assertEqual(__, place)</code></p><hr>What is also common is to have lists of tuples, like this.<br><br>delft = (52.0116, 'N', 4.3571, 'E')<div>hawaii = (19.8968, 'N', 155.5828, 'W')</div><div>maui = (20.7984, 'N', 156.3319, 'W')</div><div><br></div><div>trip = [delft, hawaii, maui]</div><div><br></div><div>This might look a bit strange, since we have a list of different things now (strings and floats), but since these are inside the elements of the list, the list is homogenous after all!</div><br><p>What are the types of trip, and trip[0]?</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/04 Nesting tuples/87808_04_code.step.py</p><hr><p><code>delft = (52.0116, 'N', 4.3571, 'E')
hawaii = (19.8968, 'N', 155.5828, 'W')
maui = (20.7984, 'N', 156.3319, 'W')
trip = [delft, hawaii, maui]

assertEqual(__, type(trip))
assertEqual(__, type(trip[0]))</code></p><hr><br><p>Now find out what trip[0][0] is.</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/04 Nesting tuples/87808_06_code.step.py</p><hr><p><code>delft = (52.0116, 'N', 4.3571, 'E')
hawaii = (19.8968, 'N', 155.5828, 'W')
maui = (20.7984, 'N', 156.3319, 'W')
trip = [delft, hawaii, maui]

assertEqual(__, type(trip[0][0]))</code></p><hr><h3>05 Unpacking tuples</h3>We already know that we can access elements of a tuple, like we can access elements of lists. So it we have a tuple like this:<div><br></div><div><pre><code>address = ('Mekelweg', '4', '2628CD', 'Delft')</code></pre></div><div><br></div><div>We could, in theory, loop over the tuple, like this.</div><div><br></div><div><pre><code>for a in address:<br>    print(a)</code></pre> </div><div><br>Do not explore this code in the next step! As you have learned in the previous lesson, tuples conceptually represent one item, so looping over them does not really make sense.</div><p>What does commonly happen is that we have a list of tuples, for example a list of people, like this:</p><p>a = ('Albert', 'Einstein')<br>b = ('Barbara', 'Liskov')<br>c = ('Charles', 'Babbage')<br>d = ('Dorothy', 'Vaughan')</p><p>cool_people = [a, b, c, d]</p><p>We can, of course, simply loop over this list, since it is a list of things. Do try that in the next step.</p><br><p>Print all tuples in the list.</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/05 Unpacking tuples/87810_03_code.step.py</p><hr><p><code>a = ('Albert', 'Einstein')
b = ('Barbara', 'Liskov')
c = ('Charles', 'Babbage')
d = ('Dorothy', 'Vaughan')
cool_people = [a, b, c, d]

for person in __:
     print(person)</code></p><hr><p>Indeed, if we loop over a list of tuples, each item is a tuple.</p><p>a = ('Albert', 'Einstein')<br>b = ('Barbara', 'Liskov')<br>c = ('Charles', 'Babbage')<br>d = ('Dorothy', 'Vaughan')<br>cool_people = [a, b, c, d]<br><br>for person in cool_people:<br>     print(person)<br></p><p>Support we want to print all last names. We could, of course, access elements in the tuple.</p><p>Explore that in the next step.</p><p><br></p><br><p>Print all last names by accessing tuple elements.</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/05 Unpacking tuples/87810_06_code.step.py</p><hr><p><code>a = ('Albert', 'Einstein')
b = ('Barbara', 'Liskov')
c = ('Charles', 'Babbage')
d = ('Dorothy', 'Vaughan')
cool_people = [a, b, c, d]
for person in cool_people:
    print(person)</code></p><hr><p>In the previous step we got last names by looking inside the tuple, like this:</p><p><br></p>a = ('Albert', 'Einstein')<br>b = ('Barbara', 'Liskov')<br>c = ('Charles', 'Babbage')<br>d = ('Dorothy', 'Vaughan')<br>cool_people = [a, b, c, d]<br>for person in cool_people:<br>    print(person[1])<div><br></div><div>It works, but it is not very elegant, since it does not clearly communicate what element we are printing. A nice way it to unpack tuples with looping. Try it in the next step</div><br><p>What are first and last? Can you use this to print all last names?</p></br><p>Code below is found in Python files/15 Chapter 3.1 - About Tuples/05 Unpacking tuples/87810_08_code.step.py</p><hr><p><code>a = ('Albert', 'Einstein')
b = ('Barbara', 'Liskov')
c = ('Charles', 'Babbage')
d = ('Dorothy', 'Vaughan')
cool_people = [a, b, c, d]
for first, last in cool_people:
    print(__)</code></p><hr><h2>16 Chapter 3.2 - About Functions & Procedures</h2><h3>01 Calling Functions</h3><p>In math class, you have certainly learned about functions. For example, a canonical function is the square function.<br><br>f: f(n) = n * n<br><br>This defines a function called that takes one argument and returns the square of it. So f(5) = 25.</p><p><span>In programming, we have function too, and you have already seen them, maybe without really realizing it.</span><br></p><p>An example of a function we have seen is len().</p><p></p><pre><code>beatles = ['John', 'Ringo', 'George', 'Paul']<br>number_of_beatles = len(beatles)</code></pre> <br>Like f(n), len(beatles) takes an argument, and returns a value. In the case of len() the argument is list and the value is integer.<br><br>This is commonly denoted as list -&gt; int.<div><br></div><div><p></p></div>When we feed Python the wrong type of argument, often we will get an error.<div><br>Try this in the next step.</div><br><p>Run the code to see what happens when we try to retrieve the length of one number, which is not a list.</p><p>Note: First run the code as it is, and only then fix the code by making a list with on element on line 1.</p></br><p>Code below is found in Python files/16 Chapter 3.2 - About Functions & Procedures/01 Calling Functions/87798_04_code.step.py</p><hr><p><code>list_of_one = 5
should_be_one = len(list_of_one)
print(should_be_one)</code></p><hr><p>When we feed Python a wrong type, most often we get a TypeError that is quite helpful. </p><p><img src="https://ucarecdn.com/61f94d9c-8617-4a7c-87b3-f0d4a5345735/" title="Image: https://ucarecdn.com/61f94d9c-8617-4a7c-87b3-f0d4a5345735/"></p><p><br></p>What we have not seen yet, is what happens when we feed Python the wrong number of elements.<div><br>Let's try that too!</div><br><p>What happens when we give len() too many arguments?</p></br><p>Code below is found in Python files/16 Chapter 3.2 - About Functions & Procedures/01 Calling Functions/87798_07_code.step.py</p><hr><p><code>list_of_one = [5]
should_be_one = len(list_of_one, 2)
print(should_be_one)</code></p><hr><br><p>And what happens when we give len() too <i>few</i> arguments?<br></p></br><p>Code below is found in Python files/16 Chapter 3.2 - About Functions & Procedures/01 Calling Functions/87798_08_code.step.py</p><hr><p><code>list_of_ine = [5]
should_be_one = len()
print(should_be_one)</code></p><hr>Here the errors, again, are pretty clear:<br><br>len() takes exactly one argument, and when more or less are given, Python warns us:<br><br><div><img src="https://ucarecdn.com/a3ba831a-2257-4a1b-a12a-29b4221df9f8/" title="Image: https://ucarecdn.com/a3ba831a-2257-4a1b-a12a-29b4221df9f8/"></div><div><br></div><img src="https://ucarecdn.com/387e4fed-3874-4fcd-8a29-50542db00e59/" title="Image: https://ucarecdn.com/387e4fed-3874-4fcd-8a29-50542db00e59/">In later modules, we will also learn how to create our own functions.<div><br></div><div>For now, the next lesson is about functions that do not look like functions!</div><h3>02 Functions that do not look like functions</h3>Some functions are clearly functions, but they do not look the part. <br><br>An example is +. + certainly is a function, it takes two numbers and returns the sum of those numbers. <br>So its type is two integers -&gt; integer.<br>This is commonly written as integer x integer -&gt; integer<div><br></div><div>Based on what we have seen, the add function should be a name, followed by a round bracket, an comma's to separate the arguments:</div><div><br></div><div>+(5, 3) or<br>plus(5,3)</div><div><br></div><div>However, in some cases, like +, the creator of Python has decided to create handy shortcuts, so we can type more natural looking statements in the form of 4 + 7.</div><div><br></div><div>Note that not all programming languages follow this line, there are languages where an addition can only be written as +(4,5)! </div><div><br></div><p>Another hidden function is indexing!</p><p></p><pre><code>primes = [2, 3, 5, 7, 11, 13]<br>second_prime = primes[1]      #&lt;-- indexing is like a function<br>print(second_prime)</code></pre><br>Think about that a bit more in the next quiz.<p></p><p><br></p><p><br></p><p>Indexing is a function that takes a list (primes) and an integer (1) and returns an integer.</p><code><pre><code>primes = [2, 3, 5, 7, 11, 13]<br>second_prime = primes[1]      #&lt;-- indexing is like a function<br>print(second_prime)</code></pre><br></code>Even though the code is written in a different way, what happens internally is something like second_prime = index(primes, 1)<h3>03 Side effects</h3><p>Functions somehow are logical to us, since they also occur in mathematics. </p><p><span>However, functions in programming are a bit different, in that they can also return.... nothing, but still do something.</span></p><p><span>An example we have seen numerous times is:</span><br></p><p></p><pre><code>print('Hello')</code></pre><br>It looks like a function, and takes a parameter between round brackets, 'Hello', but it does not return anything. <p></p><p>Verify that print() does not return anything by assigning its result to a variable in the next step.</p><br><p>Compare these two lines:</p><p><span></span></p><pre><code><span>x = abs(-4)   #abs is a function, so we can store the results<br></span>y = print(-4)  # can we store the results of print too?</code></pre> <br>To fix the code, simply print -4 by changing line 2.<p></p></br><p>Code below is found in Python files/16 Chapter 3.2 - About Functions & Procedures/03 Side effects/87938_02_code.step.py</p><hr><p><code>x = abs(-4)   #abs is a function, so we can store the results
y = print(-4)  # can we store the results of print too?</code></p><hr>A function that does something other than simply returning a value, is said to have 'side effects'.<div><br></div><div>Realizing what effects a function has it paramount to understanding programs, so we will practice with it a lot after this lesson.</div><p>Like functions that return something, functions that have side effects are sometimes written in alternative ways.</p><p>For example, list.append()</p><p></p><pre><code>beatles = ['John', 'Ringo', 'George', 'Paul']<br>beatles.append('Pete')</code></pre> <br>What is/are the parameter(s) of this function? Answer that in the next step.<p></p><div>The side effect of print() is simply putting something on the screen. <br><span><br>The side effect of append() is an interesting one. It changes one of its own parameters.<br><br></span></div><div><code><pre><code>beatles = ['John', 'Ringo', 'George', 'Paul']    #&lt;-- beatles contains 4 elements<br>beatles.append('Pete')                           #&lt;-- beatles now contains 5 elements</code></pre></code></div><div><br></div>After the append(), beatles has one extra element. This is still a side effect, because it is not returning anything.<br><div><br></div><br><p>Does append return something?<br>Try it with this code.</p><p><span>To make the code pass simply print all 5 Beatles, by changing line 2.</span><br></p></br><p>Code below is found in Python files/16 Chapter 3.2 - About Functions & Procedures/03 Side effects/87938_07_code.step.py</p><hr><p><code>beatles = ['John', 'Ringo', 'George', 'Paul']    #<-- beatles contains 4 elements
five_beatles = beatles.append('Pete')            #<-- beatles now contains 5 elements
print(five_beatles)</code></p><hr><div><span class="wysiwyg-color-black">Now, some functions return something <i>and</i> have side effects!</span></div><div></div><div>An example of a function that is pop()</div><div><br></div><div><pre><code>stack = [1, 2, 3, 4]<br>lucky_number = stack.pop()    #&lt;-- pop gets the last element (4) and also removes it<br>print(lucky_number)           #&lt;-- lucky_number now contains 4<br>print(stack)                  #&lt;-- stack now contains [1, 2, 3]</code></pre> <br><div>Like append, and +, pop() is also a function that is written in a different way. What we actually have internally is pop(stack). Pop is a function <span>on a list, and thus is of type list -&gt; integer.<br><br>But the list also changes, because the final element is removed. That still counts as a side effect.</span></div><div><br><br><div><br></div></div></div><h3>04 Overloading</h3><p>Now maybe you have noticed that some functions can be applied on different types.</p><p>Explore that in the next quiz.</p><p><br></p><br><p>Try to apply abs() on different types.</p><p>To make the code pass, print the absolute value of int_variable (-3).<br></p></br><p>Code below is found in Python files/16 Chapter 3.2 - About Functions & Procedures/04 Overloading/87939_04_code.step.py</p><hr><p><code>int_variable = -3
float_variable = -4.6
list_variable = [2, 4, 6, 8]
string_variable = 'word'
print(abs(__))</code></p><hr>Indeed, abs() can be applied on different types: float and int.<div><br></div><div><pre><code>abs(-3.1) </code></pre><br>is valid code, but also <br><br><pre><code>abs(-3)</code></pre><br><br><br><br><br><br><br></div><br><p>What types can we add?</p></br><p>Code below is found in Python files/16 Chapter 3.2 - About Functions & Procedures/04 Overloading/87939_07_code.step.py</p><hr><p><code>int_variable = -3
int_variable_2 = 5
assertEqual(__, int_variable + int_variable_2)

float_variable = -4.6
float_variable_2 = -4.6
assertEqual(__, float_variable + float_variable_2)

string_variable = 'word'
string_variable_2 = 'up'
assertEqual(__, string_variable + string_variable_2)

even_list_variable = [2, 4, 6, 8]
odd_list_variable = [1, 3, 5, 7]
assertEqual(__, even_list_variable + odd_list_variable)</code></p><hr>+ too can be applied on float and int, meaning a regular mathematical plus, but also on strings and lists. <br>Then it means combining the lists, called concatenation. <br><br>Python determines what to do with the + based on the types of the parameters.<br><br>Have you tried adding two different types? int and float will work, but what about list and string? And list and int? <br><br>Explore that in the next step.<br><p>Can we add integers to float? And lists to numbers and to strings?<br><br>To make the code pass print int_variable + float_variable.</p></br><p>Code below is found in Python files/16 Chapter 3.2 - About Functions & Procedures/04 Overloading/87939_10_code.step.py</p><hr><p><code>int_variable = -3
float_variable = -4.6
string_variable = 'word'
even_list_variable = [2, 4, 6, 8]

print(__ + __)</code></p><hr>Indeed, while lists and strings can be added to itself, they cannot be added to each other. <br><br>The associated error messages are pretty informative:<div><br></div><div><span class="wysiwyg-color-red">[Screen Shot 2018-05-04 at 1.48.44 PM]</span><br></div><h2>17 Chapter 3.3 - About Comprehension</h2><h3>01 Repetition of repetition</h3>In this lesson, you will learn a new way of looping over lists. Before we do that, let's revisit what we already know about loops.<div>Remember when we want to capitalize all words in this sentence:</div><div><br></div><div><pre><code>input = "I love programming and Python is nice"</code></pre><br>We first transformed the string into a list, with split:<br><br></div><div><pre><code>words = input.split()</code></pre><br>We created a new, empty list:<br><br></div><div><pre><code>output = []</code></pre></div><div><br>Then, for every word, we made it uppercase, and added it to the new list<br><pre><code>for w in words:<br>    uppercase_w = w.capitalize()    <br>    output.append(uppercase_w)</code></pre> <br></div><div>So, all in all, the loop part of the code is 4 lines long:</div><div><br></div><div><div><pre><code>output = []
for w in words:
    uppercase_w = w.capitalize()    
    output.append(uppercase_w)</code></pre></div><br>In the nest steps, we will learn a trick to do this in only 1 line of code!</div>The new Python command is called comprehension, and it's a new way to loop over lists. <div><br>The old version that you already know, and saw in the previous step is:<br><br></div><pre><code><div>input = "I love programming and Python is nice"</div><div>words = input.split()</div><div> output = []</div><div> for w in words:</div><div>     uppercase_w = w.capitalize()</div><div>     output.append(uppercase_w)</div></code></pre><div><br>If we expressed that in natural language, it would be something like:<br><br><i>"for every w in the list of words, capitalize it and add it to a new list output"</i><br><br>In a new form, it will be more like this:</div><div><br></div><div><i>"output is a new list, created by capitalizing every word w in words"</i><br><br>In Python it looks like this:</div><div><br></div><div><pre><code>output = [w.capitalize() for w in words]  </code></pre> <br></div><div><div>Note that there is no colon (:) after <code>for</code> in this case!</div><div><br></div><div><br></div></div><br><p>Explore a list comprehension yourself.</p></br><p>Code below is found in Python files/17 Chapter 3.3 - About Comprehension/01 Repetition of repetition/87973_03_code.step.py</p><hr><p><code>feast = ['lambs', 'sloths', 'orangutans', 'breakfast cereals', 'fruit bats']
comprehension = [delicacy.capitalize() for delicacy in feast]
assertEqual(__, comprehension[0])
assertEqual(__, comprehension[2])</code></p><hr><br><p>Print all squares of <code>numbers</code> with a list comprehension.</p></br><p>Code below is found in Python files/17 Chapter 3.3 - About Comprehension/01 Repetition of repetition/87973_04_code.step.py</p><hr><p><code>numbers = [2, 4, 9, 11, 5]
squares = [s * s for __ in __]
print(squares)</code></p><hr><h3>02 Filtering with comprehensions</h3><br><p>When we loop over a list in the traditional way, we can also filter. We do that by adding an if in the loop.</p><div><span>Finish the code in the next step to print a list with only the temperatures above 20.</span><br></div><br><p></p></br><p>Code below is found in Python files/17 Chapter 3.3 - About Comprehension/02 Filtering with comprehensions/87975_01_code.step.py</p><hr><p><code>temperatures = [21, 10, 19, 20, 0, 31, 12]
above_20 = []
for t in __:
    if __ > 20:
        above_20.append(__)
print(above_20)</code></p><hr>This code too can be made a lot shorter with a comprehension.<div><br></div><div>We had this code:</div><div><br></div><pre><code>temperatures = [21, 10, 19, 20, 0, 31, 12]<br>above_20 = []
for t in temperatures:<br>    if t &gt; 20:<br>        above_20.append(t)</code></pre> <br>In natural language, this is would be something like:<div><br><i>"for every t in the list of temperatures, if it is above 20, add it to a new list output"</i><br><br>In a new form, it will be more like this:</div><div><br></div><div><i>"above_20 is a list with all t's for every t in the list of temperatures, if t is above 20"</i><br><br></div><div>In Python it looks like this:</div><div><br></div><div><pre><code>above_20 = [t for t in temperatures if t &gt; 20]</code></pre> 
Note that here the for and also the if are not followed by a colon(:).
</div><br></br><p>Code below is found in Python files/17 Chapter 3.3 - About Comprehension/02 Filtering with comprehensions/87975_03_code.step.py</p><hr><p><code>temperatures = [21, 10, 19, 20, 0, 31, 12]
above_20 = [t for t in temperatures if __ > __]
print(above_20)</code></p><hr><h3>03 Unpacking in comprehensions</h3><p>Remember that, when looping over a list of tuples, we could unpack them by giving the tuple elements names? <br><br>It worked like this:</p><p><span></span></p><pre><code><p><span>a = ('Albert', 'Einstein')
</span><span>b = ('Barbara', 'Liskov')
</span><span>c = ('Charles', 'Babbage')
</span><span>d = ('Dorothy', 'Vaughan')
</span><span>cool_people = [a, b, c, d]
</span><span>for first, last in cool_people:
</span><span>    print(last)</span></p></code></pre><p><br>This unpacking can also be done in list comprehensions. Can you figure out how?</p><p>Try it in the next step.</p><p><br></p><br><p>Print a list of all last names of the people in the list using a comprehension.</p></br><p>Code below is found in Python files/17 Chapter 3.3 - About Comprehension/03 Unpacking in comprehensions/88000_02_code.step.py</p><hr><p><code>a = ('Albert', 'Einstein')
b = ('Barbara', 'Liskov')
c = ('Charles', 'Babbage')
d = ('Dorothy', 'Vaughan')
cool_people = [a, b, c, d]
last_names_of_cool_people = [__ for first, last in __]
print(last_names_of_cool_people)</code></p><hr><h2>18 Chapter 3.4 Nesting</h2><h3>01 Nested loops</h3><p>So far, we have seen loops that run over a list or a range. <br><br>For example, we have seen:</p><p></p><pre><code>suits = ['clubs', 'diamonds', 'hearts', 'spades']<br>for suit in suits:<br> print(suit.capitalize())<br></code></pre><br>But we can also have loops that use two (or more!) lists. <br><br>They are called nested loops. Suppose we want to print all cards in the game of 'Klaverjassen'. These are the cards of value 7 and up.<br>We can create a second list for this:<div><div><p></p><p></p><pre><code>values = ['7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']</code></pre><br>We can now loops over the suits, and over the values, and print the combination of each. <br><p></p><pre><code>suits = ['clubs', 'diamonds', 'hearts', 'spades']<br>values = ['7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']<br><br>for suit in suits:<br> for value in values:<br>  print(value + ' of ' + suit.capitalize())</code></pre> <p></p><p>Explore the code in the next step.</p><p><b>Note:</b> If you know the term, what we have done is printing the <i>Cartesian product </i>of the two lists.</p><p><br></p></div></div><br><p>Some things are wrong with the nested loop. Can you fix it?</p></br><p>Code below is found in Python files/18 Chapter 3.4 Nesting/01 Nested loops/88017_02_code.step.py</p><hr><p><code>suits = ['clubs', 'diamonds', 'hearts', 'spades']
values = ['7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']
for suit in suits:
    for value in values:
    print(value + ' of ' + suit.capitalize())</code></p><hr>The order in which we places the loops matters. This loop we just printed:<div><br><pre><code>suits = ['clubs', 'diamonds', 'hearts', 'spades']<br>values = ['7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']<br>for suit in suits:<br>    for value in values:<br>    print(value + ' of ' + suit.capitalize())</code></pre> </div><div><br>Takes 'clubs' as the first item, and then traverses all values. That is why the first lines it prints are:</div><div><br></div><div>7 of Clubs<br>8 of Clubs<br>9 of Clubs<br>10 of Clubs<br>Jack of Clubs<br></div><div>...</div><div><br></div><div>If we want to print<br>7 of Clubs</div><div>7 of Diamonds<br>7 of Hearts</div><div>7 of Spades</div><div>8 of Clubs </div><div>...<br><br></div><div>What should we change?<br>Explore it in the next step.</div><br><p></p><div>We want to use the nested loops to print the cards in order of value, so:<br>7 of Clubs</div><div>7 of Diamonds<br>7 of Hearts</div><div>7 of Spades</div><div>8 of Clubs </div><div>...<br><br>How should we change the code?</div><div><br></div><br><p></p></br><p>Code below is found in Python files/18 Chapter 3.4 Nesting/01 Nested loops/88017_04_code.step.py</p><hr><p><code>suits = ['clubs', 'diamonds', 'hearts', 'spades']
values = ['7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace']
for suit in suits:
    for value in values:
        print(value + ' of ' + suit.capitalize())</code></p><hr>Indeed, the order in which the for loops are placed matters, Python wil execute the inner loop, for each element of the outer loop.<div><br></div><div>We could use nested loops to generate a list of integer points in Cartesian coordinates. Suppose we want to print all points between (-5,-5) and (5,5). </div><div><br></div><div><span class="wysiwyg-color-red">TODO mooi plaatje van the cartesian plane hier</span></div><div><br></div><div>Can you write the code to do that?</div><div><br>Try it in the next step.</div><div><br></div><br><p>Print all points between and including (-5,-5) and (5,5), ordered by the x coordinate. <br><br>So:</p><p><b>(-5, -5)</b><br><b>(-5, -4)</b><br><b>(-5, -3)</b><br><b>(-5, -2)</b><br><b>(-5, -1)</b><br><b>(-5, 0)</b><br><b>(-5, 1)</b><br><b>(-5, 2)</b><br>etc...</p></br><p>Code below is found in Python files/18 Chapter 3.4 Nesting/01 Nested loops/88017_06_code.step.py</p><hr><p><code>for x in range(-5,5):
    for y in range(-5,5):
        print(x,y)</code></p><hr><h3>02 Nested lists</h3>So far, the list we have seen contained various different things. <br><br>For example, we have seen a list of numbers:<div><br></div><div><pre><code>primes = [2, 3, 5, 7, 11, 13]</code></pre><br>A list of strings:</div><div><br></div><div><pre><code>beatles = ['John', 'Ringo', 'George', 'Paul']</code></pre></div><div><br></div><div>And even a list of tuples:<br></div><div><p></p><pre><code><p>a = ('Albert', 'Einstein')<br>b = ('Barbara', 'Liskov')<br>c = ('Charles', 'Babbage')<br>d = ('Dorothy', 'Vaughan')</p><p>cool_people = [a, b, c, d]</p></code></pre><p></p><br>What we have not seen yet (but is possible...) is a list of lists!</div><p>We can store arbitrary things in lists, so also lists! For example, suppose we have these lists:</p><pre><code><pre><code><div><pre><code>beatles = ['John', 'Ringo', 'George', 'Paul']</code></pre></div> one_direction = ['Niall', 'Liam', 'Harry', 'Louis']
</code></pre>  traveling_wilburys = ['Bob', 'George', 'Jeff', 'Roy', 'Tom']</code></pre> <br><p></p><div>We can combine them into a list of lists:<br><br></div><div><pre><code>bands_I_like = [beatles, one_direction, traveling_wilburys]</code></pre></div><div><br></div><div>We call this a <i>nested</i> list. <br>Explore how list access works in a nested list.</div><br><p>How to get element from a nested list? And how to get elements from elements of nested lists?</p></br><p>Code below is found in Python files/18 Chapter 3.4 Nesting/02 Nested lists/88018_03_code.step.py</p><hr><p><code>beatles = ['John', 'Ringo', 'George', 'Paul']
one_direction = ['Niall', 'Liam', 'Harry', 'Louis']
traveling_wilburys = ['Bob', 'George', 'Jeff', 'Roy', 'Tom']

bands_I_like = [beatles, one_direction, traveling_wilburys]
assertEqual(__, bands_I_like[0])
assertEqual(__, bands_I_like[0][0])
assertEqual(__, bands_I_like[1])
assertEqual(__, bands_I_like[2][4])</code></p><hr><h3>03 Creating matrices</h3>Matrices are an important part of many fields of mathematics. With the basic building blocks we have learned to far, we can represent matrices. For example, if we want to create the 3x3 identity matrix, we could use three lists to represent the rows:<div><br></div><div>[1, 0, 0]<br>[0, 1, 0]<br>[0, 0, 1]<div><br></div></div><div>We can then store those three lists, in a list together:</div><div><br></div><div><pre><code>identity_3 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code></pre> <br>This works, but it is not very elegant, with bigger matrices it quickly gets a bit messy.</div><div><br></div><div>You may use this syntax once in the next step, but then we will teach you a nicer way!<br><br></div><br><p>Print the 3x3 identity matrix with nested lists. </p></br><p>Code below is found in Python files/18 Chapter 3.4 Nesting/03 Creating matrices/88019_02_code.step.py</p><hr><p><code>identity_3 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
print(identity_3)</code></p><hr><h3>04 Numpy matrices</h3><p>There are many reasons that people like Python. One of the reasons is the easy to read syntax. Another reasons is that, in addition to the normal Python syntax elements, there are many Python 'modules'.</p><p><span>You can think of modules as small Python programs, which give you extra commands.</span><br></p><p>In fact we have already seen a module, when we used random numbers. For this, we needed to use:</p><p></p><pre><code>import random<br></code></pre> <br>When we import a module, we need to tell Python that we are using something from the module, by using the module name and then the function:<p></p><p></p><pre><code>dice_roll = random.randint(0,6)+1</code></pre><br><p></p>You might wonder where this module business is going and what is has to do with matrices :)<br><br>Well, there is a very well known Python module designed for working with matrices, and we learn some commends from it, to create matrices in an easier way then with nested lists.<br><br>The module's name is NumPy, and if you are interested to find out more immediately, you can check out <a rel="nofollow" href="http://www.numpy.org/">NumPy's website</a>.<div><br></div><div><br></div><p>Let's use NumPy to create a matrix in a nicer way.</p><p>Before, we used a nested list to create the identity matrix:<br><br></p><pre><code>identity_basic = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code></pre><br><p></p><p>That works, as in it, it is a representation of the data we want. But it is not very easy, and it does not print very nice. </p><p>Once we have imported NumPy, like this:</p><p>import numpy </p><p>We can create a matrix directly from a string:<br><br></p><pre><code>identity = numpy.matrix('1 0 0; 0 1 0; 0 0 1')<br></code></pre><br>That is easier on the eyes, right? And, it prints a lot nicer. Explore that in the next step<p></p><br><p>The 3x3 identity matrices are not complete. Run the code to see how they print, and then complete them.</p></br><p>Code below is found in Python files/18 Chapter 3.4 Nesting/04 Numpy matrices/88909_04_code.step.py</p><hr><p><code>identity_basic = [[1, 0, 0], [0, 1, 0]]
print("I am I3 in normal Python {0}".format(identity_basic))

import numpy
identity_numpy = numpy.matrix('1 0 0; 0 1 0')
print("I am I3 in NumPy  {0}".format(identity_numpy))</code></p><hr>As you saw in the last step, NumPy matrices print nicely, you can easily see this is the identity matrix.<div><br></div><div><span class="image-wrapper"><img src="https://ucarecdn.com/dbdb2916-5585-4f81-9d02-ee66f9270c13/" title="Image: https://ucarecdn.com/dbdb2916-5585-4f81-9d02-ee66f9270c13/" width="449px" height="208px"></span>But there is more. NumPy has a few handy build-in functions for matrix manipulation too.<br>Explore them in the next step.</div><br><p>Explore a nice way to create the matrix:</p><p></p><pre><code>[[1 2 3]<br> [4 5 6]<br> [7 8 9]]</code></pre> <p></p><p>In line 2 we create a list from 1 to 9, you should know how to do that!<br>Then in line 3 we 'reshape' this list into the form we want. Can you guess the arguments needed there?</p></br><p>Code below is found in Python files/18 Chapter 3.4 Nesting/04 Numpy matrices/88909_06_code.step.py</p><hr><p><code>import numpy
list_1_to_9 = list(range(__,__))
matrix_1_to_9 = numpy.reshape(list_1_to_9, (__, __))
print(matrix_1_to_9)</code></p><hr><br>Transposing is easy too, and works exactly how you would expect. <div>The command is:<br><br></div><div><pre><code>numpy.transpose(matrix)</code></pre></div><div><div><br>Use the transpose command, to print this matrix: </div><div><br></div><pre><pre><code>[[1 4 7]
 [2 5 8]
 [3 6 9]]</code></pre><br></pre>This of course is the transposed version of the matrix we created in the previous step.</div></br><p>Code below is found in Python files/18 Chapter 3.4 Nesting/04 Numpy matrices/88909_07_code.step.py</p><hr><p><code>import numpy
list_1_to_9 = list(range(1,10))
matrix_1_to_9 = numpy.reshape(list_1_to_9, (3, 3))
transposed = ___(matrix_1_to_9)
print(transposed)</code></p><hr>These were just the basic things you can do with a NumPy matrix, in later lessons we will do more cool things like matrix multiplication, eigenvalues and more.<h2>19 Exploratory Zone!</h2><h3>01 Code and Warning!</h3><div>This message is only for students participating in the MasterClass Next Generation Robotics!</div><div><br></div>Great, y<span>ou reached the end of the lessons, here is the code to submit: GUIDO-ABC</span><div><br></div><div>There is more content, so feel free to explore!</div><p>So far, we have presented you with guided steps. From now on, all lessons are exploratory. We are not sure we will keep all lessons like this, but this is the way they are now. </p><p>In all steps, you will have to fill blanks to learn about new statements, but they will look a bit differently. </p><p>We will guide you through one example and then you are on your own.</p><p><br></p><br>Here is one example of the assignments you will see from now on.<div><br></div><div>There are a few new things. One new thing is the first two lines:</div><div><br></div><div><pre><code>class AboutAssignments(unittest.TestCase):<br>    def test_if_then_else_statement_true_expression(self):</code></pre> <br></div><div>You can safely ignore them, but sometimes the name of the test (on the second line) contains a hint on what to do.</div><div><br></div><div>What is also new is the form of the assert. Before we used a simple assert, like this:</div><div><br></div><div><pre><code>self.assertEqual(result == 12)</code></pre></div><div><br></div><div>We now have a special assert that checks if two things, separated by a comma, are equal:<br><br><pre><code>self.assertEqual(12, result)</code></pre><br></div><div>The basic assignment remains the same, fill in the blank (__) to make to the code work!</div><div><br></div><div>A good strategy is to run the code first, without changing something, and then reading the error message.</div><div><br></div><div><span>You will have notice that the error messages look different now:</span><br></div><div><div><img alt="" src="https://ucarecdn.com/00552908-7f92-45ad-9039-b509e663b81b/" title="Image: https://ucarecdn.com/00552908-7f92-45ad-9039-b509e663b81b/"><br></div><div>The first lines may be ignored as before. We read from , line like we were used to.</div><div><br></div><div>It now says:</div><div><br></div><div>AssertionError: '-=&gt; FILL ME IN! &lt;=-' != 'small enough'<br></div><div><br></div><div>That means that the assert is comparing '-=&gt; FILL ME IN! &lt;=-' (which is the blank) with 'small enough' which are not the same. And it is your job to fix it!</div><br></div><div><br></div><div>Maybe you have noticed the error messages look different now too:<div><img alt="" src="https://ucarecdn.com/00552908-7f92-45ad-9039-b509e663b81b/"><br></div><div>The first lines may be ignored as before. We read from , line like we were used to.</div><div><br></div><div>It now says:</div><div><br></div><div>AssertionError: '-=&gt; FILL ME IN! &lt;=-' != 'small enough'<br></div><div><br></div><div>That means that the assert is comparing '-=&gt; FILL ME IN! &lt;=-' (which is the blank) with 'small enough' which are not the same. And it is your job to fix it!</div><br></div></br><p>Code below is found in Python files/19 Exploratory Zone!/01 Code and Warning!/83901_03_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    def test_if_then_else_statement_true_expression(self):
        threshold = 12
        if 5 < threshold:
            result = 'small enough'
        else:
            result = 'too big!'
        self.assertEqual(__, result)</code></p><hr><p>Enjoy the next steps of learning Python and let us know if you are stuck!</p><h2>20 Chapter 3 - About File IO</h2><h3>01 test_reading_full_file</h3><br></br><p>Code below is found in Python files/20 Chapter 3 - About File IO/01 test_reading_full_file/78684_01_code.step.py</p><hr><p><code>class AboutFileIO(unittest.TestCase):

    def test_reading_full_file(self):
        the_file = open("one_line.txt")
        contents = the_file.read()

        self.assertEqual(__, contents)</code></p><hr><h3>02 test_reading_file_with_multiple_lines</h3><br></br><p>Code below is found in Python files/20 Chapter 3 - About File IO/02 test_reading_file_with_multiple_lines/78685_01_code.step.py</p><hr><p><code>class AboutFileIO(unittest.TestCase):

    def test_reading_file_with_multiple_lines(self):
        the_file = open("short_lines.txt")

        print(the_file)
        contents = the_file.read()

        self.assertEqual(__, contents)</code></p><hr><h3>03 test_reading_lines_directly</h3><br></br><p>Code below is found in Python files/20 Chapter 3 - About File IO/03 test_reading_lines_directly/78686_01_code.step.py</p><hr><p><code>class AboutFileIO(unittest.TestCase):

    def test_reading_lines_directly(self):
        the_file = open("short_lines.txt")

        lines = the_file.readlines()

        self.assertEqual(__, lines)</code></p><hr><h3>04 test_reading_file_line_by_line</h3><br></br><p>Code below is found in Python files/20 Chapter 3 - About File IO/04 test_reading_file_line_by_line/78687_01_code.step.py</p><hr><p><code>class AboutFileIO(unittest.TestCase):

    def test_reading_file_line_by_line(self):
        the_file = open("short_lines.txt")

        a_line = the_file.readline()
        self.assertEqual(__, a_line)

        another_line = the_file.readline()
        self.assertEqual(__, another_line)

        one_more = the_file.readline()
        self.assertEqual(__, one_more)</code></p><hr><h3>05 test_reading_file_with_for</h3><br></br><p>Code below is found in Python files/20 Chapter 3 - About File IO/05 test_reading_file_with_for/78688_01_code.step.py</p><hr><p><code>class AboutFileIO(unittest.TestCase):

    def test_reading_file_with_for(self):
        the_file = open("short_lines.txt")

        lines = list()

        for line in the_file:
            lines.append(line)

        self.assertEqual(__, lines)</code></p><hr><h3>06 test_reading_file_with_for_strip</h3><br></br><p>Code below is found in Python files/20 Chapter 3 - About File IO/06 test_reading_file_with_for_strip/78689_01_code.step.py</p><hr><p><code>class AboutFileIO(unittest.TestCase):

    def test_reading_file_with_for_strip(self):
        the_file = open("short_lines.txt")

        lines = list()

        for line in the_file:
            line = line.strip()
            lines.append(line)

        self.assertEqual(__, lines)</code></p><hr><h3>07 test_reading_file_with_with</h3><br></br><p>Code below is found in Python files/20 Chapter 3 - About File IO/07 test_reading_file_with_with/78690_01_code.step.py</p><hr><p><code>class AboutFileIO(unittest.TestCase):

    def test_reading_file_with_with(self):
        # there are a number of reasons for it,
        # but using with is the prefered way of opening a file
        # feel free to read up on that if you are interested!

        with open("short_lines.txt") as file:
            self.assertEqual(__, len(file.readlines()))</code></p><hr><h2>21 Chapter 4 - About Exceptions</h2><h3>01 test_catch_problems</h3><br></br><p>Code below is found in Python files/21 Chapter 4 - About Exceptions/01 test_catch_problems/78691_01_code.step.py</p><hr><p><code>class AboutExceptions(unittest.TestCase):

    def test_catch_problems(self):

        try:
            result = 12 / 0
        except Exception:
            result = "You can't divide by zero, silly."

        self.assertEqual(__, result)</code></p><hr><h3>02 test_can_return_message</h3><br></br><p>Code below is found in Python files/21 Chapter 4 - About Exceptions/02 test_can_return_message/78692_01_code.step.py</p><hr><p><code>class AboutExceptions(unittest.TestCase):

    def test_can_return_message(self):

        try:
            result = 12 / 0
        except Exception as ex:
            result = ex.args[0]

        self.assertEqual(__, result)</code></p><hr><h3>03 test_types_of_exceptions</h3><br></br><p>Code below is found in Python files/21 Chapter 4 - About Exceptions/03 test_types_of_exceptions/78693_01_code.step.py</p><hr><p><code>class AboutExceptions(unittest.TestCase):

    def test_types_of_exceptions(self):

        try:
            the_file = open("spoon.txt")
        except ZeroDivisionError as ex:
            result = "You found a division error!"

        except IOError as ex:
            result = "There is no spoon"

        self.assertEqual(__, result)</code></p><hr><h3>04 test_finally</h3><br></br><p>Code below is found in Python files/21 Chapter 4 - About Exceptions/04 test_finally/78694_01_code.step.py</p><hr><p><code>class AboutExceptions(unittest.TestCase):

    def test_finally(self):

        try:
            result = 12 / 0
        except ZeroDivisionError:
            result = "You can't divide by zero, silly."
        finally:
            result = "Nevermind"

        self.assertEqual(__, result)</code></p><hr><h3>05 test_finally_success</h3><br></br><p>Code below is found in Python files/21 Chapter 4 - About Exceptions/05 test_finally_success/78695_01_code.step.py</p><hr><p><code>class AboutExceptions(unittest.TestCase):

    def test_finally_success(self):

        try:
            result = 12 / 3
        except ZeroDivisionError:
            result = "You can't divide by zero, silly."
        finally:
            result = "Nevermind"

        self.assertEqual(__, result)</code></p><hr><h3>06 test_assert_is_raised</h3><br></br><p>Code below is found in Python files/21 Chapter 4 - About Exceptions/06 test_assert_is_raised/78696_01_code.step.py</p><hr><p><code>class AboutExceptions(unittest.TestCase):

    def test_assert_is_raised(self):
        with self.assertRaises(__):
            result = 12 / 0</code></p><hr><h2>22 Chapter 4 - About Creating Methods and Functions</h2><h3>01 Functions and their types</h3><br></br><p>Code below is found in Python files/22 Chapter 4 - About Creating Methods and Functions/01 Functions and their types/78726_01_code.step.py</p><hr><p><code>def add(a, b):
    return a + b

class AboutFunctions(unittest.TestCase):
    def test_calling_a_function(self):
        self.assertEqual(__, add(2, 3))</code></p><hr><h3>02 Functions that do not look like functions</h3>Some functions are clearly functions, but they do not look the part. <br><br>An example is +. + certainly is a function, it takes two numbers and returns the sum of those numbers. <br>So its type is two integers -&gt; integer.<br>This is commonly written as integer x integer -&gt; integer<div><br></div><div>Based on what we have seen, the add function should be a name, followed by a round bracket, an comma's to separate the arguments:</div><div><br></div><div>+(5, 3) or<br>plus(5,3)</div><div><br></div><div>However, in some cases, like +, the creator of Python has decided to create handy shortcuts, so we can type more natural looking statements in the form of 4 + 7.</div><div><br></div><div>Note that not all programming languages follow this line, there are languages where an addition can only be written as +(4,5)! </div><div><br></div><p>Another hidden function is indexing!</p><p></p><pre><code>primes = [2, 3, 5, 7, 11, 13]<br>second_prime = primes[1]      #&lt;-- indexing is like a function<br>print(second_prime)</code></pre><br>Think about that a bit more in the next quiz.<p></p><p><br></p><p><br></p><p>Indexing is a function that takes a list (primes) and an integer (1) and returns an integer.</p><code><pre><code>primes = [2, 3, 5, 7, 11, 13]<br>second_prime = primes[1]      #&lt;-- indexing is like a function<br>print(second_prime)</code></pre><br></code>Even though the code is written in a different way, what happens internally is something like second_prime = index(primes, 1)<h3>03 test_calling_with_default_values</h3><br></br><p>Code below is found in Python files/22 Chapter 4 - About Creating Methods and Functions/03 test_calling_with_default_values/78727_01_code.step.py</p><hr><p><code>def format_info(name, age = 18):
   """This returns the passed info as a nicely formatted string"""
   name_and_age_formatted = "{0} is currently {1} years old".format(name,age)

   return name_and_age_formatted

class AboutFunctions(unittest.TestCase):
    def test_calling_with_default_values(self):
        self.assertEqual(__, format_info('Arnold', 70))
        self.assertEqual(__, format_info('Elle'))</code></p><hr><h3>04 test_calling_with_named_parameters</h3><br></br><p>Code below is found in Python files/22 Chapter 4 - About Creating Methods and Functions/04 test_calling_with_named_parameters/78728_01_code.step.py</p><hr><p><code>def format_info(name, age = 18):
   """This returns the passed info as a nicely formatted string"""
   name_and_age_formatted = "{0} is currently {1} years old".format(name,age)

   return name_and_age_formatted

class AboutFunctions(unittest.TestCase):
    def test_calling_with_named_parameters(self):
        self.assertEqual(__, format_info(name = 'Chatum', age=37))
        self.assertEqual(__, format_info(age = 47, name = 'Matthew'))</code></p><hr><h3>05 test_with_variable_number_of_arguments</h3><br></br><p>Code below is found in Python files/22 Chapter 4 - About Creating Methods and Functions/05 test_with_variable_number_of_arguments/78729_01_code.step.py</p><hr><p><code>def print_all_these(*args):
    to_print = ""
    for a in args:
        to_print += a + " "
    return to_print


class AboutFunctions(unittest.TestCase):
    def test_with_variable_number_of_arguments(self):
        self.assertEqual(__, print_all_these('Huey'))
        self.assertEqual(__, print_all_these('Huey','Dewey'))
        self.assertEqual(__, print_all_these('Huey','Dewey','Louie'))</code></p><hr><h3>06 test_function_too_can_have_documentation</h3><br></br><p>Code below is found in Python files/22 Chapter 4 - About Creating Methods and Functions/06 test_function_too_can_have_documentation/78730_01_code.step.py</p><hr><p><code>def format_info(name, age = 18):
   """This returns the passed info as a nicely formatted string"""
   name_and_age_formatted = "{0} is currently {1} years old".format(name,age) 

class AboutFunctions(unittest.TestCase):
    def test_function_too_can_have_documentation(self):
        self.assertEqual(__, format_info.__doc__)</code></p><hr><h3>07 test_function_which_does_not_return_anything</h3><br></br><p>Code below is found in Python files/22 Chapter 4 - About Creating Methods and Functions/07 test_function_which_does_not_return_anything/78733_01_code.step.py</p><hr><p><code>def pointless_method(a, b):
    sum = a + b

class AboutFunctions(unittest.TestCase):
    def test_function_which_does_not_return_anything(self):
        self.assertEqual(__, pointless_method(1, 2))</code></p><hr><h3>08 test_function_that_do_nothing_need_to_use_pass_as_a_filler</h3><br></br><p>Code below is found in Python files/22 Chapter 4 - About Creating Methods and Functions/08 test_function_that_do_nothing_need_to_use_pass_as_a_filler/78734_01_code.step.py</p><hr><p><code>def empty_method():
    pass

class AboutFunctions(unittest.TestCase):
    def test_function_that_do_nothing_need_to_use_pass_as_a_filler(self):
        self.assertEqual(__, empty_method())</code></p><hr><h2>23 Chapter 3.5 - About None</h2><h3>01 What is None?</h3>So far we have seen two important built-in constants in Python, <code>True</code> and <code>False</code>.
<div><br></div><div>These represent something that is True or False. There is one more of these we need to know about, and that is None.</div><div><br></div><div>None represents the situation where a variable has no value. I know that sounds very weird! None is a value but also it isn't. </div><div><br></div><div>Yup! Let's just look at an example first.</div><br><p>In lines 1 and 2 we define a function that looks like it doubles in input. But....! There is no return line, so the function will not return anything.</p><p>That is were <code>None</code> comes in.</p><p>See what happens when we assign the result of no_return_double_function(5) to a variable.</p></br><p>Code below is found in Python files/23 Chapter 3.5 - About None/01 What is None?/88924_02_code.step.py</p><hr><p><code>def no_return_double(n):
    a = n + n
what_am_I = no_return_double(5)
assertEqual(__, what_am_I)</code></p><hr>So a function that does not return anything, still returns something, the built-in constant None.<div><br></div><div>None is different from both True and False, and 0. You can explore that in the next step.</div><br><p>None is not equal to True, False, or 0. </p><p><span>You might think "of course it is not 0!", but there also are programming languages where a function that does not return something, returns 0 by default. </span><br></p></br><p>Code below is found in Python files/23 Chapter 3.5 - About None/01 What is None?/88924_04_code.step.py</p><hr><p><code>assertEqual(__, None is not True)
assertEqual(__, None is not False)
assertEqual(__, None is not 0)</code></p><hr><h3>02 Testing for None</h3>There are some functions that sometimes return None. An example of this is getting an element from a dictionary with get().<div><br></div><div>In earlier lesson, we used get() with two arguments:</div><div><br></div><div><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}<br>four_in_spanish = babel_fish.get(4, 'Key not found in the dictionary') #&lt;-- contains 'Key not found in the dictionary'</code></pre> <br>But, we can do it with one too:<br><div><div><br></div><div><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}<br>four_in_spanish = babel_fish.get(4) #&lt;-- contains None<br><br></code></pre><br></div><div>Then None is returned with the key is not found, so in de code above, four_in_spanish now contains None.<br></div><div><br></div><div>Try it in the next step.</div><div><br></div><div>Note: None is not the string <b>None</b>. So no quotes (') or double quotes (") are needed around it.</div><div><br></div><div><br></div></div></div><br></br><p>Code below is found in Python files/23 Chapter 3.5 - About None/02 Testing for None/88935_02_code.step.py</p><hr><p><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}
four_in_spanish = babel_fish.get(4) #<-- contains None
assertEqual(__, four_in_spanish)</code></p><hr>Suppose we want to check whether our retrieval from the dictionary has resulted in None, for example because we want to print the resulting word, but only when it is found.<div><br></div><div>We would do something like:<br><br></div><div><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}<br>four_in_spanish = babel_fish.get(4) #&lt;-- contains None<br>if four_in_spanish == None:
    print(four_in_spanish)
else:
    print('The key was not found')
</code></pre><br>However! In the case of None, we do not use == but is, like this:<br><div><br></div><div></div></div><pre><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}<br>four_in_spanish = babel_fish.get(4) #&lt;-- contains None<br>if four_in_spanish is None:  #&lt;-- when we are checking if something is None we use is and not ==!
    print(four_in_spanish)
else:
    print('The key was not found')</code></pre> <br><p>Run the code with is and verify that this indeed works. In later lessons we will explain exactly what the differences between == and is are, but for now just remember that with None, it is better to use is.</p></br><p>Code below is found in Python files/23 Chapter 3.5 - About None/02 Testing for None/88935_04_code.step.py</p><hr><p><code>babel_fish = {1: 'uno', 2: 'dos', 3: 'tres'}
four_in_spanish = babel_fish.get(4) #<-- contains None
if four_in_spanish is None:  #<-- when we are checking if something is None we use is and not ==!
    result = four_in_spanish
else:
    result = 'The key was not found'

assertEqual(__, result)</code></p><hr><h3>03 infinity and NaN</h3>In addition to None, there are two more similar constructs you should know about, when working with large and small numbers.<div><br></div><div>While we human can count arbitrary far, computers cannot. There is a limit to the numbers they can store.</div><div><br></div><div>The highest number that Python can store is:<br><br></div><div><pre><code>max = 1.7976931348623157e+308</code></pre><br></div><div>If we try to make that number bigger, for example by multiplying it by itself, we get an interesting answer. Try it in the next step.</div><br><p>What happens if we multiple a very large number?</p><p><br></p></br><p>Code below is found in Python files/23 Chapter 3.5 - About None/03 infinity and NaN/88969_02_code.step.py</p><hr><p><code>max = 1.7976931348623157e+308
assertEqual(__, str(max * max))</code></p><hr>Indeed, Python returns inf, which represents infinity. We can calculate with infinity in Python and it obeys the normal rules of infinity.<div><br></div><div>For example: </div><div><ul><li>infinity/x = infinity, for any x</li><li>x/infinity = 0, for any x</li><li>infinity * x = infinity, for any x</li></ul><p>Explore it in the next step.</p><p><br></p></div><br><div>We now create infinity directly, rather than as a result of a calculation. For this we import the math module of which it is part.<br><br></div><div><pre><code>import math
test = math.inf</code></pre></div><div><br></div>Verify that these rules hold for infinity in Python:
<br><br><li>infinity/x = infinity, for any x</li><li>x/infinity = 0, for any x</li><li>infinity * x = infinity, for any x</li>

</br><p>Code below is found in Python files/23 Chapter 3.5 - About None/03 infinity and NaN/88969_04_code.step.py</p><hr><p><code>import math
infinity = math.inf
assertEqual(infinity, infinity / __)
assertEqual(__, 12/infinity)
assertEqual(__, infinity * 12)</code></p><hr>Now this of course leads to an interesting question....!<div><br></div><div>We now that in mathematics, infinity / infinity is undefined. What would it be in Python?</div><br><p>What is infinity/infinity?</p></br><p>Code below is found in Python files/23 Chapter 3.5 - About None/03 infinity and NaN/88969_06_code.step.py</p><hr><p><code>import math
infinity = math.inf
assertEqual(__, str(infinity/infinity))</code></p><hr>You can add text and also images, math formulas, code examples and much more in this theory step.<h2>24 Chapter 4 - About Recursion</h2><h3>01 test_functions_can_call_each_other</h3><br></br><p>Code below is found in Python files/24 Chapter 4 - About Recursion/01 test_functions_can_call_each_other/78738_01_code.step.py</p><hr><p><code>def add(a, b):
    return a + b

def multiply_by_adding(a, b):
    total = 0
    for i in range(b):
        total = add(a, total)
    return total

class AboutAssignments(unittest.TestCase):
    def test_functions_can_call_each_other(self):
        self.assertEqual(__, multiply_by_adding(5,3))</code></p><hr><h3>02 test_functions_can_call_themselves</h3><br></br><p>Code below is found in Python files/24 Chapter 4 - About Recursion/02 test_functions_can_call_themselves/78739_01_code.step.py</p><hr><p><code>def factorial(a):
    if a == 1:
        return 1
    else:
        return a * factorial(a-1)

class AboutAssignments(unittest.TestCase):
    def test_functions_can_call_themselves(self):
        self.assertEqual(__, factorial(7))</code></p><hr><h3>03 test_recursive_function_can_have_more_base_cases</h3><br></br><p>Code below is found in Python files/24 Chapter 4 - About Recursion/03 test_recursive_function_can_have_more_base_cases/78740_01_code.step.py</p><hr><p><code>def add(a, b):
    return a + b

def fibonacci(a):
    if a == 1:
        return __
    elif a == 2:
        return __
    else:
        return __ + __

class AboutAssignments(unittest.TestCase):
    def test_recursive_function_can_have_more_base_cases(self):
        self.assertEqual(13, fibonacci(8))</code></p><hr><h2>25 Chapter 4 - About Lambdas</h2><h3>01 test_lambdas_can_be_assigned_to_variables_and_called_explicitly</h3><br></br><p>Code below is found in Python files/25 Chapter 4 - About Lambdas/01 test_lambdas_can_be_assigned_to_variables_and_called_explicitly/78741_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    def test_lambdas_can_be_assigned_to_variables_and_called_explicitly(self):
        add_one = lambda n: n + 1
        self.assertEqual(__, add_one(10))</code></p><hr><h3>02 test_accessing_lambda_via_assignment</h3><br></br><p>Code below is found in Python files/25 Chapter 4 - About Lambdas/02 test_accessing_lambda_via_assignment/78742_01_code.step.py</p><hr><p><code>def make_order_for(foodtype):
    return lambda qty: str(qty) + " " + foodtype + "s"

class AboutAssignments(unittest.TestCase):
    def test_accessing_lambda_via_assignment(self):

        sausages = make_order_for('sausage')
        eggs = make_order_for('egg')

        self.assertEqual(__, sausages(3))
        self.assertEqual(__, eggs(2))</code></p><hr><h3>03 test_accessing_lambda_without_assignment</h3><br></br><p>Code below is found in Python files/25 Chapter 4 - About Lambdas/03 test_accessing_lambda_without_assignment/78743_01_code.step.py</p><hr><p><code>def make_order_for(foodtype):
    return lambda qty: str(qty) + " " + foodtype + "s"

class AboutAssignments(unittest.TestCase):
    def test_accessing_lambda_without_assignment(self):
        self.assertEqual(__, make_order_for('spam')(39823))</code></p><hr><h2>26 Chapter 5 - About Classes</h2><h3>01 test_instances_of_classes_can_be_created_with_parentheses</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/01 test_instances_of_classes_can_be_created_with_parentheses/78744_01_code.step.py</p><hr><p><code>class Dog:
    """Dogs need regular walks. Never, ever let them drive."""
    age = 1

    def age_in_dog_years(self):
        return self.age * 7

class AboutClasses(unittest.TestCase):

    def test_instances_of_classes_can_be_created_with_parentheses(self):
        fido = Dog()
        self.assertEqual(Dog, _________(fido))</code></p><hr><h3>02 test_classes_have_documentation_too</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/02 test_classes_have_documentation_too/78745_01_code.step.py</p><hr><p><code>class Dog:
    """Dogs need regular walks. Never, ever let them drive."""
    age = 1

    def age_in_dog_years(self):
        return self.age * 7

class AboutClasses(unittest.TestCase):
    def test_classes_have_documentation_too(self):
        self.assertEqual(Dog.__doc__, __)</code></p><hr><h3>03 test_classes_have_documentation_too_two</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/03 test_classes_have_documentation_too_two/78746_01_code.step.py</p><hr><p><code>class Cat:
    __
    def __init__(self, n):
        self.name = n

    def what_am_I(self):
        return self

class AboutClasses(unittest.TestCase):
    def test_classes_have_documentation_too_two(self):
        self.assertEqual(Cat.__doc__, "Cats can walk themselves. Go away!")
        # Hint: Where is the blank for this Koan?</code></p><hr><h3>04 test_we_can_determine_what_class_a_variable_has</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/04 test_we_can_determine_what_class_a_variable_has/78747_01_code.step.py</p><hr><p><code>class Dog:
    """Dogs need regular walks. Never, ever let them drive."""
    age = 1

    def age_in_dog_years(self):
        return self.age * 7

class AboutClasses(unittest.TestCase):
    def test_we_can_determine_what_class_a_variable_has(self):
        fido = Dog()
        self.assertEqual(__, isinstance(fido, Dog))
        self.assertEqual(False, isinstance(fido, __))</code></p><hr><h3>05 test_objects_have_data</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/05 test_objects_have_data/78748_01_code.step.py</p><hr><p><code>class Dog:
    """Dogs need regular walks. Never, ever let them drive."""
    age = 1

    def age_in_dog_years(self):
        return self.age * 7

class AboutClasses(unittest.TestCase):

    def test_objects_have_data(self):
        fido = Dog()
        self.assertEqual(__, fido.age)</code></p><hr><h3>06 test_objects_have_methods</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/06 test_objects_have_methods/78749_01_code.step.py</p><hr><p><code>class Dog:
    """Dogs need regular walks. Never, ever let them drive."""
    age = 1

    def age_in_dog_years(self):
        return self.age * 7


class AboutClasses(unittest.TestCase):

    def test_objects_have_methods(self):
        fido = Dog()
        self.assertEqual(__, fido.age_in_dog_years())</code></p><hr><h3>07 test_init_is_a_special_method</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/07 test_init_is_a_special_method/78750_01_code.step.py</p><hr><p><code>class Bird:
    def __init__(self):
        self.age = 1 

class AboutClasses(unittest.TestCase):

    def test_init_is_a_special_method(self):
        tweety = Bird()
        self.assertEqual(__, tweety.age)</code></p><hr><h3>08 test_init_method_can_also_take_data</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/08 test_init_method_can_also_take_data/78751_01_code.step.py</p><hr><p><code>class Cat:
    def __init__(self, n):
        self.name = n

    def what_am_I(self):
        return self        

class AboutClasses(unittest.TestCase):

    def test_init_method_can_also_take_data(self):
        felix = Cat("Felix Domestica Prima")
        self.assertEqual(__, felix.name)</code></p><hr><h3>09 test_methods_use_data</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/09 test_methods_use_data/78752_01_code.step.py</p><hr><p><code>class FancyCat:
    def __init__(self, n, t):
        self.name = n
        self.title = t

    def get_full_name(self):
        return "{0}. {1}".format(__,self.name)        

class AboutClasses(unittest.TestCase):

    def test_methods_use_data(self):
        evil_cat = FancyCat("Bigglesworth", "Mr")
        self.assertEqual("Mr. Bigglesworth", evil_cat.get_full_name())
        # Hint: Where is the blank for this Koan?</code></p><hr><h3>10 test_different_objects_have_different_instance_variables</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/10 test_different_objects_have_different_instance_variables/78753_01_code.step.py</p><hr><p><code>class FancyCat:
    def __init__(self, n, t):
        self.name = n
        self.title = t

    def get_full_name(self):
        return "{0}. {1}".format(__,self.name)

class AboutClasses(unittest.TestCase):

    def test_different_objects_have_different_instance_variables(self):
        magically_evil_cat = FancyCat("Norris", "Mrs")
        evil_cat = FancyCat("Bigglesworth", "Mr")

        self.assertEqual(__, magically_evil_cat.title)
        self.assertEqual(__, evil_cat.name)</code></p><hr><h3>11 test_methods_can_take_parameters</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/11 test_methods_can_take_parameters/78754_01_code.step.py</p><hr><p><code>class Puppy:
    def give_food(self, food):
        return "Yum, I like {0}".format(food)

class AboutClasses(unittest.TestCase):

    def test_methods_can_take_parameters(self):
        fluffy = Puppy()
        self.assertEqual("Yum, I like potatoes", fluffy.give_food(__))</code></p><hr><h3>12 test_methods_can_take_parameters_and_use_data</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/12 test_methods_can_take_parameters_and_use_data/78755_01_code.step.py</p><hr><p><code>class Kitten:
    def __init__(self, favorite_food):
        self.favorite_food = favorite_food

    def give_food(self, food):
        if food == self.favorite_food:
            return "Yum!"
        else:
            return "Uuuuuuugh!"

class AboutClasses(unittest.TestCase):

    def test_methods_can_take_parameters_and_use_data(self):
        garfield = Kitten("lasagna")
        self.assertEqual(__, garfield.give_food("potatoes"))
        self.assertEqual("Yum!", garfield.give_food(__))</code></p><hr><h3>13 test_classes_may_be_nested</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/13 test_classes_may_be_nested/78756_01_code.step.py</p><hr><p><code>class AboutClasses(unittest.TestCase):
    class Turtle:
        def __init__(self, n):
            self.name = n

    def test_classes_may_be_nested(self):
        sheldon = self.Turtle('Sheldon')
        self.assertEqual(__, type(sheldon))</code></p><hr><h3>14 test_referencing_different_classes</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/14 test_referencing_different_classes/78757_01_code.step.py</p><hr><p><code>class Puppy:
    def give_food(self, food):
        return "Yum, I like {0}".format(food)

class AboutClasses(unittest.TestCase):

    class Puppy:
        def give_food(self, food):
            return "More {0} please".format(food)

    def test_referencing_different_classes(self):
        beethoven = Puppy()
        fang = self.Puppy()

        self.assertEqual("Yum, I like shoes", beethoven.give_food(__))
        self.assertEqual(__, fang.give_food("shoes"))</code></p><hr><h3>15 test_what_is_self_here</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/15 test_what_is_self_here/78758_01_code.step.py</p><hr><p><code>class AboutClasses(unittest.TestCase):

    def test_what_is_self_here(self):
        self.assertEqual(__, type(self))</code></p><hr><h3>16 test_self_aware</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/16 test_self_aware/78759_01_code.step.py</p><hr><p><code>class AI:
    def is_self_aware(self):
        return AI == type(self)

class AboutClasses(unittest.TestCase):

    def test_self_aware(self):
        alexa = AI()
        self.assertEqual(__, alexa.is_self_aware())</code></p><hr><h3>17 test_self_can_be_returned</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/17 test_self_can_be_returned/78760_01_code.step.py</p><hr><p><code>class Calculator:
    total = 0

    def add(self, value):
        self.total += value
        return self

class AboutClasses(unittest.TestCase):

    def test_self_can_be_returned(self):
        c = Calculator()
        c.add(1).add(1).add(1)
        self.assertEqual(__, c.total)</code></p><hr><h3>18 test_type_of_return_self_is</h3><br></br><p>Code below is found in Python files/26 Chapter 5 - About Classes/18 test_type_of_return_self_is/78761_01_code.step.py</p><hr><p><code>class Calculator:
    total = 0

    def add(self, value):
        self.total += value
        return self

class AboutClasses(unittest.TestCase):

    def test_type_of_return_self_is(self):
        c = Calculator()

        self.assertEqual(Calculator, _________(c.add(1)))</code></p><hr><h2>27 Week 5 - About Printing Classes</h2><h3>01 test_str_provides_a_string_version_of_the_object</h3><br></br><p>Code below is found in Python files/27 Week 5 - About Printing Classes/01 test_str_provides_a_string_version_of_the_object/78762_01_code.step.py</p><hr><p><code>class AboutPrintingClasses(unittest.TestCase):
    class PrintableDog:
        def __init__(self, initial_name):
            self._name = initial_name

        def __str__(self):
            #
            # Implement this!
            #
            return __

        def __repr__(self):
            return "A dog named '" + self._name + "'"

    def test_str_provides_a_string_version_of_the_object(self):
        sue = self.PrintableDog("Sue")

        self.assertEqual("Sue", str(sue))</code></p><hr><h3>02 test_str_is_used_explicitly_in_string_interpolation</h3><br></br><p>Code below is found in Python files/27 Week 5 - About Printing Classes/02 test_str_is_used_explicitly_in_string_interpolation/78763_01_code.step.py</p><hr><p><code>class AboutPrintingClasses(unittest.TestCase):
    class PrintableDog:
        def __init__(self, initial_name):
            self._name = initial_name

        def __str__(self):
            return self._name

        def __repr__(self):
            return "A dog named '" + self._name + "'"

    def test_str_is_used_explicitly_in_string_interpolation(self):
        sue = self.PrintableDog("Sue")

        self.assertEqual(__, "My name is " + str(sue) + ". How do you do?")</code></p><hr><h3>03 test_repr_provides_a_more_complete_string_version</h3><br></br><p>Code below is found in Python files/27 Week 5 - About Printing Classes/03 test_repr_provides_a_more_complete_string_version/78764_01_code.step.py</p><hr><p><code>class AboutPrintingClasses(unittest.TestCase):
    class PrintableDog:
        def __init__(self, initial_name):
            self._name = initial_name

        def __str__(self):
            return self._name

        def __repr__(self):
            return "A dog named '" + self._name + "'"

    def test_repr_provides_a_more_complete_string_version(self):
        sue = self.PrintableDog("Sue")
        self.assertEqual(__, repr(sue))</code></p><hr><h3>04 test_all_objects_support_str_and_repr</h3><br></br><p>Code below is found in Python files/27 Week 5 - About Printing Classes/04 test_all_objects_support_str_and_repr/78765_01_code.step.py</p><hr><p><code>class AboutPrintingClasses(unittest.TestCase):

    def test_all_objects_support_str_and_repr(self):
        seq = [1, 2, 3]

        self.assertEqual(__, str(seq))
        self.assertEqual(__, repr(seq))

        self.assertEqual(__, str("STRING"))
        self.assertEqual(__, repr("STRING"))</code></p><hr><h2>28 Chapter 5 - About Inheritance</h2><h3>01 test_dogs_are_still_dogs</h3><br></br><p>Code below is found in Python files/28 Chapter 5 - About Inheritance/01 test_dogs_are_still_dogs/78766_01_code.step.py</p><hr><p><code>class AboutInheritance(unittest.TestCase):

    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    def test_dogs_are_still_dogs(self):
        boef = self.Dog('Boef')
        self.assertEqual(self.Dog, __)</code></p><hr><h3>02 test_but_what_are_chihuahuas</h3><br></br><p>Code below is found in Python files/28 Chapter 5 - About Inheritance/02 test_but_what_are_chihuahuas/78767_01_code.step.py</p><hr><p><code>class AboutInheritance(unittest.TestCase):

    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Chihuahua(Dog):
        def wag(self):
            return "happy"

    def test_but_what_are_chihuahuas(self):
        tinkerbell = self.Chihuahua('Tinkerbell')
        self.assertEqual(__, type(tinkerbell))</code></p><hr><h3>03 test_subclasses_have_the_parent_as_an_ancestor</h3><br></br><p>Code below is found in Python files/28 Chapter 5 - About Inheritance/03 test_subclasses_have_the_parent_as_an_ancestor/78768_01_code.step.py</p><hr><p><code>class AboutInheritance(unittest.TestCase):

    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Chihuahua(Dog):
        def wag(self):
            return "happy"

    def test_subclasses_have_the_parent_as_an_ancestor(self):
        self.assertEqual(__, issubclass(self.Chihuahua, self.Dog))</code></p><hr><h3>04 test_all_defined_classes_ultimately_inherit_from_object_class</h3><br></br><p>Code below is found in Python files/28 Chapter 5 - About Inheritance/04 test_all_defined_classes_ultimately_inherit_from_object_class/78769_01_code.step.py</p><hr><p><code>class AboutInheritance(unittest.TestCase):

    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Chihuahua(Dog):
        def wag(self):
            return "happy"

    def test_all_defined_classes_ultimately_inherit_from_object_class(self):
        self.assertEqual(__, issubclass(self.Chihuahua, object))</code></p><hr><h3>05 test_all_built_in_classes_ultimately_inherit_from_object_class</h3><br></br><p>Code below is found in Python files/28 Chapter 5 - About Inheritance/05 test_all_built_in_classes_ultimately_inherit_from_object_class/78770_01_code.step.py</p><hr><p><code>class AboutInheritance(unittest.TestCase):

    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Chihuahua(Dog):
        def wag(self):
            return "happy"

    def test_all_built_in_classes_ultimately_inherit_from_object_class(self):
        self.assertEqual(__, issubclass(str, object))</code></p><hr><h3>06 test_instances_inherit_behavior_from_parent_class</h3><br></br><p>Code below is found in Python files/28 Chapter 5 - About Inheritance/06 test_instances_inherit_behavior_from_parent_class/78771_01_code.step.py</p><hr><p><code>class AboutInheritance(unittest.TestCase):
    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Chihuahua(Dog):
        def wag(self):
            return "happy"

    def test_instances_inherit_behavior_from_parent_class(self):
        chico = self.Chihuahua("Chico")
        self.assertEqual(__, chico.name)</code></p><hr><h3>07 test_subclasses_add_new_behavior</h3><br></br><p>Code below is found in Python files/28 Chapter 5 - About Inheritance/07 test_subclasses_add_new_behavior/78772_01_code.step.py</p><hr><p><code>class AboutInheritance(unittest.TestCase):
    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Chihuahua(Dog):
        def wag(self):
            return "happy"

    def test_subclasses_add_new_behavior(self):
        chico = self.Chihuahua("Chico")
        self.assertEqual(__, chico.wag())

        fido = self.Dog("Fido")
        with self.assertRaises(___): fido.wag()</code></p><hr><h2>29 Chapter 5 - About Class Attributes</h2><h3>01 test_classes_have_their_own_attributes_too</h3><br></br><p>Code below is found in Python files/29 Chapter 5 - About Class Attributes/01 test_classes_have_their_own_attributes_too/78773_01_code.step.py</p><hr><p><code>class AboutClassAttributes(unittest.TestCase):

    class Dog:
        """I am a dog without a name."""
        bionomal_name = "Canine"

    def test_classes_have_their_own_attributes_too(self):
        fido = self.Dog()
        self.assertEqual(__, fido.bionomal_name)</code></p><hr><h3>02 test_attributes_are_per_instance</h3><br></br><p>Code below is found in Python files/29 Chapter 5 - About Class Attributes/02 test_attributes_are_per_instance/78774_01_code.step.py</p><hr><p><code>class AboutClassAttributes(unittest.TestCase):
    class Dog:
        """I am a dog without a name."""
        bionomal_name = "Canine"

    def test_attributes_are_per_instance(self):
        fido = self.Dog()   
        fluffy = self.Dog()
        self.assertEqual(_____, fido.bionomal_name == fluffy.bionomal_name)
        fido.bionomal_name = "Dogum"
        self.assertEqual(______, fido.bionomal_name == fluffy.bionomal_name)</code></p><hr><h3>03 test_defining_attributes_on_individual_objects</h3><br></br><p>Code below is found in Python files/29 Chapter 5 - About Class Attributes/03 test_defining_attributes_on_individual_objects/78775_01_code.step.py</p><hr><p><code>class AboutClassAttributes(unittest.TestCase):
    class Dog:
        """I am a dog without a name."""
        bionomal_name = "Canine"

    def test_defining_attributes_on_individual_objects(self):
        fido = self.Dog()
        fido.legs = 4

        self.assertEqual(__, fido.legs)</code></p><hr><h3>04 test_attributes_are_not_shared</h3><br></br><p>Code below is found in Python files/29 Chapter 5 - About Class Attributes/04 test_attributes_are_not_shared/78776_01_code.step.py</p><hr><p><code>class AboutClassAttributes(unittest.TestCase):
    class Dog:
        """I am a dog without a name."""
        bionomal_name = "Canine"

    def test_attributes_are_not_shared(self):
        fido = self.Dog()
        fido.legs = 4
        fluffy = self.Dog()

        with self.assertRaises(___): fluffy.legs</code></p><hr><h3>05 test_defining_functions_on_individual_objects</h3><br></br><p>Code below is found in Python files/29 Chapter 5 - About Class Attributes/05 test_defining_functions_on_individual_objects/78777_01_code.step.py</p><hr><p><code>class AboutClassAttributes(unittest.TestCase):
    class Dog:
        """I am a dog without a name."""
        bionomal_name = "Canine"

    def test_defining_functions_on_individual_objects(self):
        fido = self.Dog()
        fido.bark = lambda x : 'bark ' + x

        self.assertEqual(__, fido.bark("I like swimming"))</code></p><hr><h3>06 test_other_objects_are_not_affected_by_these_singleton_functions</h3><br></br><p>Code below is found in Python files/29 Chapter 5 - About Class Attributes/06 test_other_objects_are_not_affected_by_these_singleton_functions/78778_01_code.step.py</p><hr><p><code>class AboutClassAttributes(unittest.TestCase):
    class Dog:
        """I am a dog without a name."""
        bionomal_name = "Canine"

    def test_other_objects_are_not_affected_by_these_singleton_functions(self):
        fido = self.Dog()
        fido.bark = lambda x : 'bark ' + x

        self.assertEqual(__, fido.bark("I like swimming"))

        rover = self.Dog()

        with self.assertRaises(___): rover.wag()</code></p><hr><h2>30 Chapter 5 - About Overloading</h2><h3>01 test_subclasses_can_overload_existing_behavior</h3><br></br><p>Code below is found in Python files/30 Chapter 5 - About Overloading/01 test_subclasses_can_overload_existing_behavior/78779_01_code.step.py</p><hr><p><code>class AboutOverloading(unittest.TestCase):

    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Chihuahua(Dog):
        def wag(self):
            return "happy"

        def bark(self):
            return "woof woof"

    def test_subclasses_can_overload_existing_behavior(self):
        chico = self.Chihuahua("Chico")
        self.assertEqual(__, chico.bark())

        fido = self.Dog("Fido")
        self.assertEqual(__, fido.bark())</code></p><hr><h3>02 test_subclasses_can_invoke_parent_behavior_via_super</h3><br></br><p>Code below is found in Python files/30 Chapter 5 - About Overloading/02 test_subclasses_can_invoke_parent_behavior_via_super/78780_01_code.step.py</p><hr><p><code>class AboutOverloading(unittest.TestCase):
    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class BullDog(Dog):
        def bark(self):
            return super().bark() + ", GRR"

    def test_subclasses_can_invoke_parent_behavior_via_super(self):
        ralph = self.BullDog("Ralph")
        self.assertEqual(__, ralph.bark())</code></p><hr><h3>03 test_super_works_across_methods</h3><br></br><p>Code below is found in Python files/30 Chapter 5 - About Overloading/03 test_super_works_across_methods/78781_01_code.step.py</p><hr><p><code>class AboutOverloading(unittest.TestCase):
    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class GreatDane(Dog):
        def growl(self):
            return super().bark() + ", GROWL"

    def test_super_works_across_methods(self):
        george = self.GreatDane("George")
        self.assertEqual(__, george.growl())</code></p><hr><h3>04 test_base_init_does_not_get_called_automatically</h3><br></br><p>Code below is found in Python files/30 Chapter 5 - About Overloading/04 test_base_init_does_not_get_called_automatically/78782_01_code.step.py</p><hr><p><code>class AboutOverloading(unittest.TestCase):
    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Pug(Dog):
        def __init__(self, name):
            pass

    class Greyhound(Dog):
        def __init__(self, name):
            super().__init__(name)

    def test_base_init_does_not_get_called_automatically(self):
        snoopy = self.Pug("Snoopy")
        with self.assertRaises(___): name = snoopy.name</code></p><hr><h3>05 test_base_init_has_to_be_called_explicitly</h3><br></br><p>Code below is found in Python files/30 Chapter 5 - About Overloading/05 test_base_init_has_to_be_called_explicitly/78783_01_code.step.py</p><hr><p><code>class AboutOverloading(unittest.TestCase):

    class Dog:
        def __init__(self, name):
            self._name = name

        @property
        def name(self):
            return self._name

        def bark(self):
            return "WOOF"

    class Greyhound(Dog):
        def __init__(self, name):
            super().__init__(name)

    def test_base_init_has_to_be_called_explicitly(self):
        boxer = self.Greyhound("Boxer")
        self.assertEqual(__, boxer.name)</code></p><hr><h2>31 Chapter 6 - About Deleting Objects</h2><h3>01 test_del_can_remove_methods</h3><br></br><p>Code below is found in Python files/31 Chapter 6 - About Deleting Objects/01 test_del_can_remove_methods/78784_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Bird:
        def __init__(self):
            self.wings = 2

        def fly(self):
            return "I believe I can fly"

    def test_del_can_remove_methods(self):
        flappy = self.Bird()
        polly = self.Bird()

        del self.Bird.fly

        try:
            still_available = flappy.fly()
        except AttributeError as e:
            error_message_flappy = e.args[0]
        self.assertEqual(error_message_flappy, __)

        try:
            still_available = polly.fly()
        except AttributeError as e:
            error_message_polly = e.args[0]
        self.assertEqual(error_message_polly, __)</code></p><hr><h3>02 test_del_can_remove_attributes_from_instances</h3><br></br><p>Code below is found in Python files/31 Chapter 6 - About Deleting Objects/02 test_del_can_remove_attributes_from_instances/78785_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Bird:
        def __init__(self):
            self.wings = 2

        def fly(self):
            return "I believe I can fly"

    def test_del_can_remove_attributes_from_instances(self):
        flappy = self.Bird()
        del flappy.wings

        try:
            number_of_wings = flappy.wings
        except AttributeError as e:
            error_message = e.args[0]

        self.assertEqual(error_message, __)

        polly = self.Bird()
        number_of_wings = polly.wings

        self.assertEqual(number_of_wings, __)</code></p><hr><h3>03 test_del_can_remove_entire_lists</h3><br></br><p>Code below is found in Python files/31 Chapter 6 - About Deleting Objects/03 test_del_can_remove_entire_lists/78786_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    def test_del_can_remove_entire_lists(self):
        lottery_nums = [4, 8, 15, 16, 23, 42]
        del lottery_nums

        with self.assertRaises(___): win = lottery_nums</code></p><hr><h3>04 test_del_can_remove_from_list</h3><br></br><p>Code below is found in Python files/31 Chapter 6 - About Deleting Objects/04 test_del_can_remove_from_list/78787_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    def test_del_can_remove_from_list(self):
        lottery_nums = [4, 8, 15, 16, 23, 42]
        del lottery_nums[1]
        del lottery_nums[2:4]

        self.assertEqual(___, lottery_nums)</code></p><hr><h2>32 Chapter 6 - About Properties</h2><h3>01 test_fields_are_mutable</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/01 test_fields_are_mutable/78788_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Person:
        def __init__(self):
            self.age = 10

        def drive(self):
            if self.age < 18:
                return  "Too young"
            else:
                return "VROOM VROOM"

    def test_fields_are_mutable(self):
        the_flash = self.Person()
        self.assertEqual("Too young", the_flash.drive())
        the_flash.__ = 24
        self.assertEqual("VROOM VROOM", the_flash.drive())</code></p><hr><h3>02 test_properties_can_be_read_only</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/02 test_properties_can_be_read_only/78789_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class ImmutablePerson:
        def __init__(self):
            self._age = 10

        @property
        def age(self):
            return self._age

    def test_properties_can_be_read_only(self):
        the_flash = self.ImmutablePerson()
        self.assertEqual(10, the_flash.age)

        with self.assertRaises(___):
            the_flash.age = 24</code></p><hr><h3>03 test_adding_setters_makes_properties_mutable</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/03 test_adding_setters_makes_properties_mutable/78790_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class MutablePerson:
        def __init__(self):
            self._age = 10

        @property
        def age(self):
            return self._age

        @age.setter
        def age(self, value):
            self._age = value

    def test_adding_setters_makes_properties_mutable(self):
        the_flash = self.MutablePerson()
        self.assertEqual(_____, the_flash.age)
        the_flash.age = 24
        self.assertEqual(______, the_flash.age)</code></p><hr><h3>04 test_properties_are_methods_that_can_be_accessed_like_variables</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/04 test_properties_are_methods_that_can_be_accessed_like_variables/78791_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class MutablePerson:
        def __init__(self):
            self._age = 10

        @property
        def age(self):
            return self._age

        @age.setter
        def age(self, value):
            self._age = value

    def test_properties_are_methods_that_can_be_accessed_like_variables(self):
        the_flash = self.MutablePerson()
        self.assertEqual(10, the_flash.age)
        the_flash.age += _____
        self.assertEqual(24, the_flash.age)</code></p><hr><h3>05 test_validation</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/05 test_validation/78792_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Doctor:
        def __init__(self):
            self._age = 903

        @property
        def age(self):
            return self._age

        @age.setter
        def age(self, value):
            if value < self.age:
                pass
                # nice try! you can't get any younger
            else:
                self._age = value

    def test_validation(self):
        david = self.Doctor()
        self.assertEqual(903, david.age)
        david.age = 9
        self.assertEqual(__, david.age)</code></p><hr><h3>06 test_validation2</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/06 test_validation2/78793_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Doctor:
        def __init__(self):
            self._age = 903

        @property
        def age(self):
            return self._age

        @age.setter
        def age(self, value):
            if value < self.age:
                pass
                # nice try! you can't get any younger
            else:
                self._age = value

    def test_validation2(self):
        william = self.Doctor()
        self.assertEqual(903, william.age)
        william.age -= 9
        self.assertEqual(__, william.age)</code></p><hr><h3>07 test_validation3</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/07 test_validation3/78794_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Doctor:
        def __init__(self):
            self._age = 903

        @property
        def age(self):
            return self._age

        @age.setter
        def age(self, value):
            if value < self.age:
                pass
                # nice try! you can't get any younger
            else:
                self._age = value

    def test_validation3(self):
        jodie = self.Doctor()
        self.assertEqual(903, jodie.age)
        jodie.age += 9
        self.assertEqual(__, jodie.age)</code></p><hr><h3>08 test_assigning_values</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/08 test_assigning_values/78795_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class TicTacToe:
        def __init__(self):
            self._x = 0
            self._y = 0

        @property
        def x(self):
            return self._x

        @x.setter
        def x(self, value):
            __

    def test_assigning_values(self):
        game = self.TicTacToe()
        game.x = 3
        self.assertEqual(__,game.x)
        # hint: you need to write the setter</code></p><hr><h3>09 test_highest_value_allowed_is_three</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/09 test_highest_value_allowed_is_three/78796_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class TicTacToe:
        def __init__(self):
            self._x = 0
            self._y = 0

        @property
        def y(self):
            return self._y

        @y.setter
        def y(self, value):
            __

    def test_highest_value_allowed_is_three(self):
        game = self.TicTacToe()
        game.y = 2
        self.assertEqual(2,game.y)
        game.y = 4
        self.assertEqual(3,game.y)
        # hint: you need to write the setter</code></p><hr><h3>10 test_lowest_value_allowed_is_one</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/10 test_lowest_value_allowed_is_one/78797_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class TicTacToe:
        def __init__(self):
            self._x = 0
            self._y = 0

        @property
        def y(self):
            return self._y

        @y.setter
        def y(self, value):
            __

    def test_lowest_value_allowed_is_one(self):
        game = self.TicTacToe()
        game.y = 2
        self.assertEqual(2,game.y)
        game.y = 0
        self.assertEqual(1,game.y)
        # hint: you need to adapt the setter</code></p><hr><h3>11 test_validation_reject_invalid_values</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/11 test_validation_reject_invalid_values/78798_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Cat:
        @property
        def name(self):
            return self._name

        @name.setter
        def name(self,value):
            if value.lower() == "cat":
                raise ValueError("cats deserve a proper name")
            elif value.lower() == "dog":
                raise TypeError("what is wrong with you?!")
            else:
                self._name = value

    def test_validation_reject_invalid_values(self):
        bob = self.Cat()
        with self.assertRaises(ValueError):
            bob.name = __

        bob = self.Cat()
        with self.assertRaises(___):
            bob.name = "dog"</code></p><hr><h3>12 test_properties_allow_calculation</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/12 test_properties_allow_calculation/78799_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Counter:
        def __init__(self):
            self._count = 0

        @property
        def count(self):
            self._count += _____
            return self._count

    def test_properties_allow_calculation(self):
        graaf_tel = self.Counter()
        self.assertEqual(1, graaf_tel.count)
        self.assertEqual(2, graaf_tel.count)
        self.assertEqual(3, graaf_tel.count)</code></p><hr><h3>13 test_matching_properties_and_fields_are_used_by_convention_only</h3><br></br><p>Code below is found in Python files/32 Chapter 6 - About Properties/13 test_matching_properties_and_fields_are_used_by_convention_only/78800_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Dada:
        def __init__(self):
            self._names_are_meaningless = "Oote oote oote"

        @property
        def poetry(self):
            return self._names_are_meaningless


        @poetry.setter
        def poetry(self,value):
            self._names_are_meaningless = value

    def test_matching_properties_and_fields_are_used_by_convention_only(self):
        dada = self.Dada()
        self.assertEqual(__, dada.poetry)
        dada.__ = "Boe"
        self.assertEqual("Boe", dada.poetry)
        self.assertEqual(__, dada._names_are_meaningless)</code></p><hr><h2>33 Chapter 6 - About Attribute Acces</h2><h3>01 test_getting_field_with_getattribute</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/01 test_getting_field_with_getattribute/78801_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Panda:
        bionomal_name = "Ailuropoda melanoleuca"
        colors = ["black", "white"]

        def __init__(self, name):
            self.name = name

        def number_of_paws(self):
            return 4

    def test_getting_field_with_getattribute(self):
        wu_wen = self.Panda("Wu Wen")
        name = wu_wen.__getattribute__('name')
        self.assertEqual(__, name)</code></p><hr><h3>02 test_getting_field_with_getattribute_variable</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/02 test_getting_field_with_getattribute_variable/78802_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Panda:
        bionomal_name = "Ailuropoda melanoleuca"
        colors = ["black", "white"]

        def __init__(self, name):
            self.name = name

        def number_of_paws(self):
            return 4

    def test_getting_field_with_getattribute_variable(self):
        xing_ya = self.Panda("Xing Ya")
        attribute_to_get = "colors"

        colors = xing_ya.__getattribute__(__)
        self.assertEqual(["black", "white"], colors)</code></p><hr><h3>03 test_calling_non_existing_functions_results_in_errors</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/03 test_calling_non_existing_functions_results_in_errors/78803_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Panda:
        bionomal_name = "Ailuropoda melanoleuca"
        colors = ["black", "white"]

        def __init__(self, name):
            self.name = name

        def number_of_paws(self):
            return 4

    def test_calling_non_existing_functions_results_in_errors(self):
        xing_ya = self.Panda("Xing Ya")
        with self.assertRaises(___): xing_ya.number_of_wings()</code></p><hr><h3>04 test_calling_getattribute_causes_an_attribute_error</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/04 test_calling_getattribute_causes_an_attribute_error/78804_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class Panda:
        bionomal_name = "Ailuropoda melanoleuca"
        colors = ["black", "white"]

        def __init__(self, name):
            self.name = name

        def number_of_paws(self):
            return 4

    def test_calling_getattribute_causes_an_attribute_error(self):
        typical = self.Panda("Melan")

        with self.assertRaises(___): typical.____getattribute____('foobar')

        # THINK ABOUT IT:
        #
        # If the method __getattribute__() causes the AttributeError, then
        # what would happen if we redefine __getattribute__()?</code></p><hr><h3>05 test_all_attribute_reads_are_caught</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/05 test_all_attribute_reads_are_caught/78805_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class CatchAllAttributeReads:
        def __getattribute__(self, attr_name):
            return "Someone called '" + attr_name + "' and it could not be found"

    def test_all_attribute_reads_are_caught(self):
        catcher = self.CatchAllAttributeReads()

        self.assertEqual(catcher.foobar, __)</code></p><hr><h3>06 test_intercepting_return_values_can_disrupt_the_call_chain</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/06 test_intercepting_return_values_can_disrupt_the_call_chain/78806_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class CatchAllAttributeReads:
        def __getattribute__(self, attr_name):
            return "Someone called '" + attr_name + "' and it could not be found"

    def test_intercepting_return_values_can_disrupt_the_call_chain(self):
        catcher = self.CatchAllAttributeReads()

        self.assertEqual(catcher.foobaz, __) # This is fine

        try:
            catcher.foobaz(1)
        except TypeError as ex:
            err_msg = ex.args[0]

        self.assertRegex(err_msg, __)</code></p><hr><h3>07 test_changes_to_the_getattribute_implementation_affects_getattr_</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/07 test_changes_to_the_getattribute_implementation_affects_getattr_/78807_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class CatchAllAttributeReads:
        def __getattribute__(self, attr_name):
            return "Someone called '" + attr_name + "' and it could not be found"

    def test_changes_to_the_getattribute_implementation_affects_getattr_function(self):
        catcher = self.CatchAllAttributeReads()

        self.assertEqual(getattr(catcher, 'any_attribute'), __)</code></p><hr><h3>08 test_foo_attributes_are_caught</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/08 test_foo_attributes_are_caught/78808_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class WellBehavedFooCatcher:
        def __getattribute__(self, attr_name):
            if attr_name[:3] == "foo":
                return "Foo to you too"
            else:
                return super().__getattribute__(attr_name)

    def test_foo_attributes_are_caught(self):
        catcher = self.WellBehavedFooCatcher()

        self.assertEqual(__, catcher.foo_bar)
        self.assertEqual(__, catcher.foo_baz)</code></p><hr><h3>09 test_non_foo_messages_are_treated_normally</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/09 test_non_foo_messages_are_treated_normally/78809_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class WellBehavedFooCatcher:
        def __getattribute__(self, attr_name):
            if attr_name[:3] == "foo":
                return "Foo to you too"
            else:
                return super().__getattribute__(attr_name)

    def test_non_foo_messages_are_treated_normally(self):
        catcher = self.WellBehavedFooCatcher()

        with self.assertRaises(___): catcher.normal_undefined_attribute</code></p><hr><h3>10 test_getattr_ignores_known_attributes</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/10 test_getattr_ignores_known_attributes/78810_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class MinimalCatcher:
        class DuffObject: pass

        def __init__(self):
            self.no_of_getattr_calls = 0

        def __getattr__(self, attr_name):
            self.no_of_getattr_calls += 1
            return self.DuffObject

        def my_method(self):
            pass

    def test_getattr_ignores_known_attributes(self):
        catcher = self.MinimalCatcher()
        catcher.my_method()

        self.assertEqual(__, catcher.no_of_getattr_calls)</code></p><hr><h3>11 test_getattr_only_catches_unknown_attributes</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/11 test_getattr_only_catches_unknown_attributes/78811_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class MinimalCatcher:
        class DuffObject: pass

        def __init__(self):
            self.no_of_getattr_calls = 0

        def __getattr__(self, attr_name):
            self.no_of_getattr_calls += 1
            return self.DuffObject

        def my_method(self):
            pass

    def test_getattr_only_catches_unknown_attributes(self):
        catcher = self.MinimalCatcher()
        catcher.purple_flamingos()
        catcher.free_pie()

        self.assertEqual(__,
            type(catcher.give_me_duff_or_give_me_death()).__name__)

        self.assertEqual(__, catcher.no_of_getattr_calls)</code></p><hr><h3>12 test_setattr_intercepts_attribute_assignments</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/12 test_setattr_intercepts_attribute_assignments/78812_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class PossessiveSetter(object):
        def __setattr__(self, attr_name, value):
            new_attr_name =  attr_name

            if attr_name == 'comic':
                new_attr_name = "my_" + new_attr_name
            if attr_name == 'pie':
                new_attr_name = "a_" + new_attr_name

            object.__setattr__(self, new_attr_name, value)

    def test_setattr_intercepts_attribute_assignments(self):
        fanboy = self.PossessiveSetter()

        fanboy.pie = 'blueberry'

        self.assertEqual(__, fanboy.a_pie)
        self.assertEqual(__, fanboy.pie)</code></p><hr><h3>13 test_it_modifies_external_attribute_as_expected</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/13 test_it_modifies_external_attribute_as_expected/78813_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class ScarySetter:
        def __init__(self):
            self.num_of_coconuts = 9
            self._num_of_private_coconuts = 2

        def __setattr__(self, attr_name, value):
            new_attr_name =  attr_name

            if attr_name[0] != '_':
                new_attr_name = "altered_" + new_attr_name

            object.__setattr__(self, new_attr_name, value)

    def test_it_modifies_external_attribute_as_expected(self):
        setter = self.ScarySetter()
        setter.e = "mc hammer"

        self.assertEqual(__, setter.altered_e)</code></p><hr><h3>14 test_it_mangles_some_internal_attributes</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/14 test_it_mangles_some_internal_attributes/78814_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class ScarySetter:
        def __init__(self):
            self.num_of_coconuts = 9
            self._num_of_private_coconuts = 2

        def __setattr__(self, attr_name, value):
            new_attr_name =  attr_name

            if attr_name[0] != '_':
                new_attr_name = "altered_" + new_attr_name

            object.__setattr__(self, new_attr_name, value)

    def test_it_mangles_some_internal_attributes(self):
        setter = self.ScarySetter()

        try:
            coconuts = setter.num_of_coconuts
        except AttributeError:
            self.assertEqual(__, setter.altered_num_of_coconuts)</code></p><hr><h3>15 test_in_this_case_private_attributes_remain_unmangled</h3><br></br><p>Code below is found in Python files/33 Chapter 6 - About Attribute Acces/15 test_in_this_case_private_attributes_remain_unmangled/78815_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class ScarySetter:
        def __init__(self):
            self.num_of_coconuts = 9
            self._num_of_private_coconuts = 2

        def __setattr__(self, attr_name, value):
            new_attr_name =  attr_name

            if attr_name[0] != '_':
                new_attr_name = "altered_" + new_attr_name

            object.__setattr__(self, new_attr_name, value)

    def test_in_this_case_private_attributes_remain_unmangled(self):
        setter = self.ScarySetter()

        self.assertEqual(__, setter._num_of_private_coconuts)</code></p><hr><h2>34 Week 6 - About Defining Exceptions</h2><h3>01 test_try_clause</h3><br></br><p>Code below is found in Python files/34 Week 6 - About Defining Exceptions/01 test_try_clause/78816_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class MySpecialError(RuntimeError):
        pass

    def test_try_clause(self):
        result = None
        try:
            self.fail("Oops")
        except Exception as ex:
            result = 'exception handled'
            stored_exception = ex

        self.assertEqual(__, result)

        self.assertEqual(__, isinstance(stored_exception, Exception))
        self.assertEqual(__, isinstance(stored_exception, RuntimeError))

        self.assertTrue(issubclass(RuntimeError, __))

        self.assertEqual(__, stored_exception.args[0])</code></p><hr><h3>02 test_raising_a_specific_error</h3><br></br><p>Code below is found in Python files/34 Week 6 - About Defining Exceptions/02 test_raising_a_specific_error/78817_01_code.step.py</p><hr><p><code>class AboutAssignments(unittest.TestCase):
    class MySpecialError(RuntimeError):
        pass

    def test_raising_a_specific_error(self):
        result = None
        try:
            raise self.MySpecialError("My Message")
        except self.MySpecialError as ex:
            result = 'exception handled'
            msg = ex.args[0]

        self.assertEqual(__, result)
        self.assertEqual(__, msg)</code></p><hr><h2>35 Week 6 - About Multiple Inheritance</h2><h3>01 test_normal_methods_are_available_in_the_object</h3><br></br><p>Code below is found in Python files/35 Week 6 - About Multiple Inheritance/01 test_normal_methods_are_available_in_the_object/78818_01_code.step.py</p><hr><p><code>class AboutMultipleInheritance(unittest.TestCase):
    class Nameable:
        def __init__(self):
            self._name = None

        def set_name(self, new_name):
            self._name = new_name

        def here(self):
            return "In Nameable class"

    class Animal:
        def legs(self):
            return 4

        def can_climb_walls(self):
            return False

        def here(self):
            return "In Animal class"

    class Pig(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Jasper"

        @property
        def name(self):
            return self._name

        def speak(self):
            return "OINK"

        def color(self):
            return 'pink'

        def here(self):
            return "In Pig class"

    class Spider(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Boris"

        def can_climb_walls(self):
            return True

        def legs(self):
            return 8

        def color(self):
            return 'black'

        def here(self):
            return "In Spider class"

    class Spiderpig(Pig, Spider, Nameable):
        def __init__(self):
            super(AboutMultipleInheritance.Pig, self).__init__()
            super(AboutMultipleInheritance.Nameable, self).__init__()
            self._name = "Jeff"

        def speak(self):
            return "This looks like a job for Spiderpig!"

        def here(self):
            return "In Spiderpig class"

    #
    # Hierarchy:
    #               Animal
    #              /     \
    #            Pig   Spider  Nameable
    #              \      |      /
    #                 Spiderpig
    #
    # ------------------------------------------------------------------

    def test_normal_methods_are_available_in_the_object(self):
        jeff = self.Spiderpig()
        self.assertRegex(jeff.speak(), __)</code></p><hr><h3>02 test_base_class_methods_are_also_available_in_the_object</h3><br></br><p>Code below is found in Python files/35 Week 6 - About Multiple Inheritance/02 test_base_class_methods_are_also_available_in_the_object/78819_01_code.step.py</p><hr><p><code>class AboutMultipleInheritance(unittest.TestCase):
    class Nameable:
        def __init__(self):
            self._name = None

        def set_name(self, new_name):
            self._name = new_name

        def here(self):
            return "In Nameable class"

    class Animal:
        def legs(self):
            return 4

        def can_climb_walls(self):
            return False

        def here(self):
            return "In Animal class"

    class Pig(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Jasper"

        @property
        def name(self):
            return self._name

        def speak(self):
            return "OINK"

        def color(self):
            return 'pink'

        def here(self):
            return "In Pig class"

    class Spider(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Boris"

        def can_climb_walls(self):
            return True

        def legs(self):
            return 8

        def color(self):
            return 'black'

        def here(self):
            return "In Spider class"

    class Spiderpig(Pig, Spider, Nameable):
        def __init__(self):
            super(AboutMultipleInheritance.Pig, self).__init__()
            super(AboutMultipleInheritance.Nameable, self).__init__()
            self._name = "Jeff"

        def speak(self):
            return "This looks like a job for Spiderpig!"

        def here(self):
            return "In Spiderpig class"

    #
    # Hierarchy:
    #               Animal
    #              /     \
    #            Pig   Spider  Nameable
    #              \      |      /
    #                 Spiderpig
    #
    # ------------------------------------------------------------------

    def test_base_class_methods_are_also_available_in_the_object(self):
        jeff = self.Spiderpig()
        try:
            jeff.set_name("Rover")
        except:
            self.fail("This should not happen")
        self.assertEqual(__, jeff.can_climb_walls())</code></p><hr><h3>03 test_base_class_methods_can_affect_instance_variables_in_the_obj</h3><br></br><p>Code below is found in Python files/35 Week 6 - About Multiple Inheritance/03 test_base_class_methods_can_affect_instance_variables_in_the_obj/78820_01_code.step.py</p><hr><p><code>class AboutMultipleInheritance(unittest.TestCase):
    class Nameable:
        def __init__(self):
            self._name = None

        def set_name(self, new_name):
            self._name = new_name

        def here(self):
            return "In Nameable class"

    class Animal:
        def legs(self):
            return 4

        def can_climb_walls(self):
            return False

        def here(self):
            return "In Animal class"

    class Pig(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Jasper"

        @property
        def name(self):
            return self._name

        def speak(self):
            return "OINK"

        def color(self):
            return 'pink'

        def here(self):
            return "In Pig class"

    class Spider(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Boris"

        def can_climb_walls(self):
            return True

        def legs(self):
            return 8

        def color(self):
            return 'black'

        def here(self):
            return "In Spider class"

    class Spiderpig(Pig, Spider, Nameable):
        def __init__(self):
            super(AboutMultipleInheritance.Pig, self).__init__()
            super(AboutMultipleInheritance.Nameable, self).__init__()
            self._name = "Jeff"

        def speak(self):
            return "This looks like a job for Spiderpig!"

        def here(self):
            return "In Spiderpig class"

    #
    # Hierarchy:
    #               Animal
    #              /     \
    #            Pig   Spider  Nameable
    #              \      |      /
    #                 Spiderpig
    #
    # ------------------------------------------------------------------

    def test_base_class_methods_can_affect_instance_variables_in_the_object(self):
        jeff = self.Spiderpig()
        self.assertEqual(__, jeff.name)

        jeff.set_name("Rover")
        self.assertEqual(__, jeff.name)</code></p><hr><h3>04 test_left_hand_side_inheritance_tends_to_be_higher_priority</h3><br></br><p>Code below is found in Python files/35 Week 6 - About Multiple Inheritance/04 test_left_hand_side_inheritance_tends_to_be_higher_priority/78821_01_code.step.py</p><hr><p><code>class AboutMultipleInheritance(unittest.TestCase):
    class Nameable:
        def __init__(self):
            self._name = None

        def set_name(self, new_name):
            self._name = new_name

        def here(self):
            return "In Nameable class"

    class Animal:
        def legs(self):
            return 4

        def can_climb_walls(self):
            return False

        def here(self):
            return "In Animal class"

    class Pig(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Jasper"

        @property
        def name(self):
            return self._name

        def speak(self):
            return "OINK"

        def color(self):
            return 'pink'

        def here(self):
            return "In Pig class"

    class Spider(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Boris"

        def can_climb_walls(self):
            return True

        def legs(self):
            return 8

        def color(self):
            return 'black'

        def here(self):
            return "In Spider class"

    class Spiderpig(Pig, Spider, Nameable):
        def __init__(self):
            super(AboutMultipleInheritance.Pig, self).__init__()
            super(AboutMultipleInheritance.Nameable, self).__init__()
            self._name = "Jeff"

        def speak(self):
            return "This looks like a job for Spiderpig!"

        def here(self):
            return "In Spiderpig class"

    #
    # Hierarchy:
    #               Animal
    #              /     \
    #            Pig   Spider  Nameable
    #              \      |      /
    #                 Spiderpig
    #
    # ------------------------------------------------------------------


    def test_left_hand_side_inheritance_tends_to_be_higher_priority(self):
        jeff = self.Spiderpig()
        self.assertEqual(__, jeff.color())</code></p><hr><h3>05 test_super_class_methods_are_higher_priority_than_super_super_cl</h3><br></br><p>Code below is found in Python files/35 Week 6 - About Multiple Inheritance/05 test_super_class_methods_are_higher_priority_than_super_super_cl/78822_01_code.step.py</p><hr><p><code>class AboutMultipleInheritance(unittest.TestCase):
    class Nameable:
        def __init__(self):
            self._name = None

        def set_name(self, new_name):
            self._name = new_name

        def here(self):
            return "In Nameable class"

    class Animal:
        def legs(self):
            return 4

        def can_climb_walls(self):
            return False

        def here(self):
            return "In Animal class"

    class Pig(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Jasper"

        @property
        def name(self):
            return self._name

        def speak(self):
            return "OINK"

        def color(self):
            return 'pink'

        def here(self):
            return "In Pig class"

    class Spider(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Boris"

        def can_climb_walls(self):
            return True

        def legs(self):
            return 8

        def color(self):
            return 'black'

        def here(self):
            return "In Spider class"

    class Spiderpig(Pig, Spider, Nameable):
        def __init__(self):
            super(AboutMultipleInheritance.Pig, self).__init__()
            super(AboutMultipleInheritance.Nameable, self).__init__()
            self._name = "Jeff"

        def speak(self):
            return "This looks like a job for Spiderpig!"

        def here(self):
            return "In Spiderpig class"

    #
    # Hierarchy:
    #               Animal
    #              /     \
    #            Pig   Spider  Nameable
    #              \      |      /
    #                 Spiderpig
    #
    # ------------------------------------------------------------------

    def test_super_class_methods_are_higher_priority_than_super_super_classes(self):
        jeff = self.Spiderpig()
        self.assertEqual(__, jeff.legs())</code></p><hr><h3>06 test_we_can_inspect_the_method_resolution_order</h3><br></br><p>Code below is found in Python files/35 Week 6 - About Multiple Inheritance/06 test_we_can_inspect_the_method_resolution_order/78823_01_code.step.py</p><hr><p><code>class AboutMultipleInheritance(unittest.TestCase):
    class Nameable:
        def __init__(self):
            self._name = None

        def set_name(self, new_name):
            self._name = new_name

        def here(self):
            return "In Nameable class"

    class Animal:
        def legs(self):
            return 4

        def can_climb_walls(self):
            return False

        def here(self):
            return "In Animal class"

    class Pig(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Jasper"

        @property
        def name(self):
            return self._name

        def speak(self):
            return "OINK"

        def color(self):
            return 'pink'

        def here(self):
            return "In Pig class"

    class Spider(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Boris"

        def can_climb_walls(self):
            return True

        def legs(self):
            return 8

        def color(self):
            return 'black'

        def here(self):
            return "In Spider class"

    class Spiderpig(Pig, Spider, Nameable):
        def __init__(self):
            super(AboutMultipleInheritance.Pig, self).__init__()
            super(AboutMultipleInheritance.Nameable, self).__init__()
            self._name = "Jeff"

        def speak(self):
            return "This looks like a job for Spiderpig!"

        def here(self):
            return "In Spiderpig class"

    #
    # Hierarchy:
    #               Animal
    #              /     \
    #            Pig   Spider  Nameable
    #              \      |      /
    #                 Spiderpig
    #
    # ------------------------------------------------------------------

    def test_we_can_inspect_the_method_resolution_order(self):
        #
        # MRO = Method Resolution Order
        #
        mro = type(self.Spiderpig()).mro()
        self.assertEqual('Spiderpig', mro[0].__name__)
        self.assertEqual('Pig', mro[1].__name__)
        self.assertEqual(__, mro[2].__name__)
        self.assertEqual(__, mro[3].__name__)
        self.assertEqual(__, mro[4].__name__)
        self.assertEqual(__, mro[5].__name__)</code></p><hr><h3>07 test_confirm_the_mro_controls_the_calling_order</h3><br></br><p>Code below is found in Python files/35 Week 6 - About Multiple Inheritance/07 test_confirm_the_mro_controls_the_calling_order/78824_01_code.step.py</p><hr><p><code>class AboutMultipleInheritance(unittest.TestCase):
    class Nameable:
        def __init__(self):
            self._name = None

        def set_name(self, new_name):
            self._name = new_name

        def here(self):
            return "In Nameable class"

    class Animal:
        def legs(self):
            return 4

        def can_climb_walls(self):
            return False

        def here(self):
            return "In Animal class"

    class Pig(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Jasper"

        @property
        def name(self):
            return self._name

        def speak(self):
            return "OINK"

        def color(self):
            return 'pink'

        def here(self):
            return "In Pig class"

    class Spider(Animal):
        def __init__(self):
            super().__init__()
            self._name = "Boris"

        def can_climb_walls(self):
            return True

        def legs(self):
            return 8

        def color(self):
            return 'black'

        def here(self):
            return "In Spider class"

    class Spiderpig(Pig, Spider, Nameable):
        def __init__(self):
            super(AboutMultipleInheritance.Pig, self).__init__()
            super(AboutMultipleInheritance.Nameable, self).__init__()
            self._name = "Jeff"

        def speak(self):
            return "This looks like a job for Spiderpig!"

        def here(self):
            return "In Spiderpig class"

    #
    # Hierarchy:
    #               Animal
    #              /     \
    #            Pig   Spider  Nameable
    #              \      |      /
    #                 Spiderpig
    #
    # ------------------------------------------------------------------

    def test_confirm_the_mro_controls_the_calling_order(self):
        jeff = self.Spiderpig()
        self.assertRegex(jeff.here(), 'Spiderpig')

        next = super(AboutMultipleInheritance.Spiderpig, jeff)
        self.assertRegex(next.here(), 'Pig')

        next = super(AboutMultipleInheritance.Pig, jeff)
        self.assertRegex(next.here(), __)

        # Hang on a minute?!? That last class name might be a super class of
        # the 'jeff' object, but its hardly a superclass of Pig, is it?
        #
        # To avoid confusion it may help to think of super() as next_mro().</code></p><hr><h2>36 Week 7 - About Higher Order Functions</h2><h3>01 test_assigning_functions_to_variables</h3><br></br><p>Code below is found in Python files/36 Week 7 - About Higher Order Functions/01 test_assigning_functions_to_variables/78825_01_code.step.py</p><hr><p><code>def add(a, b):
    return a + b

class AboutHigherOrderFunctions(unittest.TestCase):

    def test_assigning_functions_to_variables(self):
        plus = add
        self.assertEqual(__, plus(5,7))</code></p><hr><h3>02 test_define_functions_in_other_functions</h3><br></br><p>Code below is found in Python files/36 Week 7 - About Higher Order Functions/02 test_define_functions_in_other_functions/78826_01_code.step.py</p><hr><p><code>def greet(name):
    def get_message():
        return "Hello there"

    result = get_message() + " {0}!".format(name)
    return result

class AboutHigherOrderFunctions(unittest.TestCase):

    def test_define_functions_in_other_functions(self):
        self.assertEqual(__, greet("Jack"))</code></p><hr><h3>03 test_functions_can_be_passed_as_parameters</h3><br></br><p>Code below is found in Python files/36 Week 7 - About Higher Order Functions/03 test_functions_can_be_passed_as_parameters/78827_01_code.step.py</p><hr><p><code>def add(a, b):
    return a + b

def multiply(a, b):
    return a * b

def apply(f, a, b):
    return f(a,b)

class AboutHigherOrderFunctions(unittest.TestCase):

    def test_functions_can_be_passed_as_parameters(self):
        self.assertEqual(__, add(2,3))
        self.assertEqual(__, apply(add,2,3))    
        self.assertEqual(6, apply(_____,2,3))</code></p><hr><h3>04 test_functions_can_return_functions</h3><br></br><p>Code below is found in Python files/36 Week 7 - About Higher Order Functions/04 test_functions_can_return_functions/78828_01_code.step.py</p><hr><p><code>def add_constant(x):
    def addx(a):
        return a+x
    return addx

class AboutHigherOrderFunctions(unittest.TestCase):

    def test_functions_can_return_functions(self):
        add5 = add_constant(5)
        self.assertEqual(__, add5(3))</code></p><hr><h3>05 test_inner_functions_have_access_to_outer_scope</h3><br></br><p>Code below is found in Python files/36 Week 7 - About Higher Order Functions/05 test_inner_functions_have_access_to_outer_scope/78829_01_code.step.py</p><hr><p><code>def greet_closure(name):
    def get_message():
        return "Hello there {0}!".format(name)

    return get_message()

class AboutHigherOrderFunctions(unittest.TestCase):

    def test_inner_functions_have_access_to_outer_scope(self):
        self.assertEqual(__, greet_closure("Rose"))</code></p><hr><h2>37 Week 7 - About Partial Application</h2><h3>01 test_partial_function_applied_regularly</h3><br><p>=<br></p></br><p>Code below is found in Python files/37 Week 7 - About Partial Application/01 test_partial_function_applied_regularly/78830_01_code.step.py</p><hr><p><code>class AboutPartialApplication(unittest.TestCase):
    def maximum(self, a, b):
        if a > b:
            return a
        else:
            return b

    def test_partial_function_applied_regularly(self):
        max = functools.partial(self.maximum)

        self.assertEqual(__, max(7, 23))
        self.assertEqual(__, max(10, -10))</code></p><hr><h3>02 test_partial__passing_first_arg</h3><br></br><p>Code below is found in Python files/37 Week 7 - About Partial Application/02 test_partial__passing_first_arg/78831_01_code.step.py</p><hr><p><code>class AboutPartialApplication(unittest.TestCase):
    def maximum(self, a, b):
        if a > b:
            return a
        else:
            return b

    def test_partial__passing_first_arg(self):
        max_with_0 = functools.partial(self.maximum, 0)

        self.assertEqual(__, max_with_0(-4))
        self.assertEqual(__, max_with_0(5))</code></p><hr><h3>03 test_partial_that_wrappers_all_args</h3><br></br><p>Code below is found in Python files/37 Week 7 - About Partial Application/03 test_partial_that_wrappers_all_args/78832_01_code.step.py</p><hr><p><code>class AboutPartialApplication(unittest.TestCase):
    def maximum(self, a, b):
        if a > b:
            return a
        else:
            return b

    def test_partial_that_wrappers_all_args(self):
        always_99 = functools.partial(self.maximum, 99, 20)
        always_20 = functools.partial(self.maximum, 9, 20)

        self.assertEqual(__, always_99())
        self.assertEqual(__, always_20())</code></p><hr><h2>38 Week 7 - About Scope</h2><h3>01 test_variable_with_same_name_is_different_variable</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/01 test_variable_with_same_name_is_different_variable/78839_01_code.step.py</p><hr><p><code>counter = 0 # Global

class AboutScope(unittest.TestCase):

    def test_variable_with_same_name_is_different_variable(self):
        counter = 12
        self.assertEqual(__, counter)</code></p><hr><h3>02 test_global_access_is_possible_with_keyword</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/02 test_global_access_is_possible_with_keyword/78840_01_code.step.py</p><hr><p><code>counter = 0 # Global

class AboutScope(unittest.TestCase):

    def test_global_access_is_possible_with_keyword(self):
        global counter
        self.assertEqual(__, counter)</code></p><hr><h3>03 test_dog_is_not_available_in_the_current_scope</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/03 test_dog_is_not_available_in_the_current_scope/78841_01_code.step.py</p><hr><p><code>class AboutScope(unittest.TestCase):

    def test_dog_is_not_available_in_the_current_scope(self):
        with self.assertRaises(___): fido = Dog()</code></p><hr><h3>04 test_you_can_reference_classes_in_files</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/04 test_you_can_reference_classes_in_files/78842_01_code.step.py</p><hr><p><code># We write the files here so you can see what they contain
f1 = open('jims_animals.py', 'w')
f1.write('''
class Dog:
    def identify(self):
        return "I am Jim's dog"
''')
f1.close()

f2 = open('joes_animals.py', 'w')
f2.write('''
class Dog:
    def identify(self):
        return "I am Joe's dog"
''')
f2.close()

# Now we import what we've just written
import jims_animals
import joes_animals

class AboutScope(unittest.TestCase):

    def test_you_can_reference_classes_in_files(self):
        # Here we use the classes in the modules we just imported
        fido = jims_animals.Dog()
        rover = joes_animals.Dog()

        self.assertEqual(__, fido.identify())
        self.assertEqual(__, rover.identify())

        self.assertEqual(__, type(fido) == type(rover))
        self.assertEqual(__, jims_animals.Dog == joes_animals.Dog)</code></p><hr><h3>05 test_nested_string_is_not_the_same_as_the_system_string</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/05 test_nested_string_is_not_the_same_as_the_system_string/78843_01_code.step.py</p><hr><p><code>class AboutScope(unittest.TestCase):
    class str:
        """Fake string. So sad!"""

    def test_nested_string_is_not_the_same_as_the_system_string(self):
        self.assertEqual(__, self.str.__doc__)</code></p><hr><h3>06 test_str_without_self_prefix_stays_in_the_global_scope</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/06 test_str_without_self_prefix_stays_in_the_global_scope/78844_01_code.step.py</p><hr><p><code>class AboutScope(unittest.TestCase):
    class str:
        """Fake string. So sad!"""

    def test_str_without_self_prefix_stays_in_the_global_scope(self):
        self.assertEqual(__, str == type("HI"))</code></p><hr><h3>07 test_constants_are_defined_with_an_initial_uppercase_letter</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/07 test_constants_are_defined_with_an_initial_uppercase_letter/78845_01_code.step.py</p><hr><p><code>class AboutScope(unittest.TestCase):
    PI = 3.1416

    def test_constants_are_defined_with_an_initial_uppercase_letter(self):
        self.assertAlmostEqual(_____, self.PI)
        # Note, floating point numbers in python are not precise.
        # assertAlmostEqual will check that it is 'close enough'</code></p><hr><h3>08 test_constants_are_assumed_by_convention_only</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/08 test_constants_are_assumed_by_convention_only/78846_01_code.step.py</p><hr><p><code>class AboutScope(unittest.TestCase):
    PI = 3.1416

    def test_constants_are_assumed_by_convention_only(self):
        self.PI = "rhubarb"
        self.assertEqual(_____, self.PI)
        # There aren't any real constants in python. Its up to the developer
        # to keep to the convention and not modify them.</code></p><hr><h3>09 test_getting_something_locally</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/09 test_getting_something_locally/78847_01_code.step.py</p><hr><p><code>class AboutScope(unittest.TestCase):
    def inside_local(self):
        msg = "Outside!"

        def inside():
            msg = "Inside!"

        inside()
        return msg

    def test_getting_something_locally(self):
        self.assertEqual(__, self.inside_local())</code></p><hr><h3>10 test_getting_something_nonlocally</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/10 test_getting_something_nonlocally/78848_01_code.step.py</p><hr><p><code>class AboutScope(unittest.TestCase):
    def inside_non_local(self):
        msg = "Outside!"

        def inside():
            nonlocal msg
            msg = "Inside!"

        inside()
        return msg

    def test_getting_something_nonlocally(self):
        self.assertEqual(__, self.inside_non_local())</code></p><hr><h3>11 test_global_attributes_can_be_created_in_the_middle_of_a_class</h3><br></br><p>Code below is found in Python files/38 Week 7 - About Scope/11 test_global_attributes_can_be_created_in_the_middle_of_a_class/78849_01_code.step.py</p><hr><p><code>class AboutScope(unittest.TestCase):
    global deadly_bingo
    deadly_bingo = [4, 8, 15, 16, 23, 42]

    def test_global_attributes_can_be_created_in_the_middle_of_a_class(self):
        self.assertEqual(__, deadly_bingo[5])</code></p><hr><h2>39 Week 7 - About Sets</h2><h3>01 test_sets_have_no_duplicates</h3><br></br><p>Code below is found in Python files/39 Week 7 - About Sets/01 test_sets_have_no_duplicates/78850_01_code.step.py</p><hr><p><code>class AboutSets(unittest.TestCase):

    def test_sets_have_no_duplicates(self):
        highlanders = ['MacLeod', 'MacLeod', 'Matunas', 'Matunas', 'Matunas', 'Malcolm', 'Malcolm']

        there_can_only_be_only_one = set(highlanders)

        self.assertEqual(__, there_can_only_be_only_one)</code></p><hr><h3>02 test_empty_sets_have_different_syntax_to_populated_sets</h3><br></br><p>Code below is found in Python files/39 Week 7 - About Sets/02 test_empty_sets_have_different_syntax_to_populated_sets/78851_01_code.step.py</p><hr><p><code>class AboutSets(unittest.TestCase):

    def test_empty_sets_have_different_syntax_to_populated_sets(self):
        self.assertEqual(__, {1, 2, 3})
        self.assertEqual(__, set())</code></p><hr><h3>03 test_dictionaries_and_sets_use_same_curly_braces</h3><br></br><p>Code below is found in Python files/39 Week 7 - About Sets/03 test_dictionaries_and_sets_use_same_curly_braces/78852_01_code.step.py</p><hr><p><code>class AboutSets(unittest.TestCase):

    def test_dictionaries_and_sets_use_same_curly_braces(self):
        self.assertEqual(__, type({1, 2, 3}))
        self.assertEqual(__, type({'one': 1, 'two': 2}))
        self.assertEqual(__, type({}))</code></p><hr><h3>04 test_creating_sets_using_strings</h3><br></br><p>Code below is found in Python files/39 Week 7 - About Sets/04 test_creating_sets_using_strings/78853_01_code.step.py</p><hr><p><code>class AboutSets(unittest.TestCase):

    def test_creating_sets_using_strings(self):
        self.assertEqual(__, {'12345'})
        self.assertEqual(__, set('12345'))</code></p><hr><h3>05 test_convert_the_set_into_a_list_to_sort_it</h3><br></br><p>Code below is found in Python files/39 Week 7 - About Sets/05 test_convert_the_set_into_a_list_to_sort_it/78854_01_code.step.py</p><hr><p><code>class AboutSets(unittest.TestCase):

    def test_convert_the_set_into_a_list_to_sort_it(self):
        self.assertEqual(__, sorted(set('52314')))</code></p><hr><h3>06 test_set_have_arithmetic_operators</h3><br></br><p>Code below is found in Python files/39 Week 7 - About Sets/06 test_set_have_arithmetic_operators/78855_01_code.step.py</p><hr><p><code>class AboutSets(unittest.TestCase):

    def test_set_have_arithmetic_operators(self):
        beatles = {'John', 'Ringo', 'George', 'Paul'}
        dead_musicians = {'John', 'George', 'Elvis', 'Tupac', 'Bowie'}

        great_musicians = beatles | dead_musicians
        self.assertEqual(__, great_musicians)

        living_beatles = beatles - dead_musicians
        self.assertEqual(__, living_beatles)

        dead_beatles = beatles & dead_musicians
        self.assertEqual(__, dead_beatles)</code></p><hr><h3>07 test_we_can_compare_subsets</h3><br></br><p>Code below is found in Python files/39 Week 7 - About Sets/07 test_we_can_compare_subsets/78856_01_code.step.py</p><hr><p><code>class AboutSets(unittest.TestCase):

    def test_we_can_compare_subsets(self):

        beatles = {'John', 'Ringo', 'George', 'Paul'}
        dead_musicians = {'John', 'George', 'Elvis', 'Tupac', 'Bowie'}

        dead_beatles = beatles & dead_musicians

        self.assertEqual(__, dead_beatles <= beatles)
        self.assertEqual(__, dead_beatles.issubset(beatles) )</code></p><hr><h3>08 test_we_can_query_set_membership</h3><br></br><p>Code below is found in Python files/39 Week 7 - About Sets/08 test_we_can_query_set_membership/78857_01_code.step.py</p><hr><p><code>class AboutSets(unittest.TestCase):

    def test_we_can_query_set_membership(self):
        beatles = {'John', 'Ringo', 'George', 'Paul'}
        one_direction = {"Harry", "Niall", "Louis", "Liam", "Zayn"}

        self.assertEqual(__, 'John' in beatles )
        self.assertEqual(__, 'Ringo' not in one_direction)</code></p><hr><h2>40 About Types</h2><h3>01 Types of numbers</h3><p>Not all numbers are created equal, numbers in Python have different types.</p><p>Integers, like 5 or 2198 are called 'int'<br>Floating point numbers, like 3.1415 and 0.0.71 are called 'float'</p><p>We can ask Python what type a certain variable is, by using type() on the variable.</p><p>Like this:</p><p></p><pre><code>temperature = 12<br>print(type(temperature))</code></pre><br>results in <br><p></p><p><b>&lt;class 'int'&gt;</b><br></p><p><b></b>This looks very cryptic---and you might learn more about classes later in your programming career---but for now what matters it the part that says <b>int</b>. That indicates that the variable temperature is of type int, meaning a whole number. <br></p><p>Similarly</p><p></p><pre><code>angle = 10.7<br>print(type(angle))</code></pre><br>results in<p></p><p><b>&lt;class 'float'&gt;</b><br></p><p><br></p><br>